* cfDNA Copy Number Alteration Analysis                             :biopipe:
:PROPERTIES:
:logging: nil
:header-args:bash: :tangle-mode (identity #o555)
:END:

** README
:PROPERTIES:
:export_file_name: ./README.md
:END:
*** Change Log
- [2022-09-12 Mon]: Version 2.1.0, added no-panel of normal outputs
- [2022-04-29 Fri]: First commit, copying from the old mpnst-cna repo. Untested.
** Documentation
** Conda
- Ichor install
  - On R version 4.5
    #+begin_src yaml :tangle ./config/ichor-conda-env.yaml
  name: ichor
  channels:
    - dranew
    - conda-forge
    - bioconda
    - defaults
  dependencies:
    - hmmcopy_utils
    - python=3.10
    - r-base=4.4
    - r-optparse
    - r-tidyverse
    - r-getopt
    - r-devtools
    - r-remotes
    - r-biocmanager
    - bioconductor-genomicfeatures
    - bioconductor-annotationdbi
    - bioconductor-biomart
    - bioconductor-hmmcopy
    - git
    - libgit2
    - curl
    - openssl
    - pkg-config
    - make
    - gcc
    - pandoc
    - snakemake

  #+end_src
    #+begin_src bash
#!/bin/bash

docker run -it -v /mnt/:/mnt/ -v /home/:/home/ ichor
cd /mnt/data/projects/breast/analysis/cna
conda activate ichor
which R

# Set Bioconductor version explicitly

Rscript -e 'BiocManager::install(version = "3.20")'

# Install ichorCNA locally
git clone https://github.com/broadinstitute/ichorCNA.git ~/repos/ichorCNA

Rscript -e 'devtools::install_local("~/repos/ichorCNA", dependencies = TRUE)'

Rscript -e 'system.file(package = "ichorCNA")'

Rscript /home/jeszyman/repos/ichorCNA/scripts/runIchorCNA.R \
	--id tumor_sample \
        --WIG frag.wig \
	--genomeBuild "hg38" \
        --ploidy "c(2,3)" --normal "c(0.5,0.6,0.7,0.8,0.9)" --maxCN 5 \
        --gcWig /home/jeszyman/repos/ichorCNA/inst/extdata/gc_hg38_1000kb.wig \
        --mapWig /home/jeszyman/repos/ichorCNA/inst/extdata/map_hg38_1000kb.wig \
        --centromere /home/jeszyman/repos/ichorCNA/inst/extdata/GRCh38.GCA_000001405.2_centromere_acen.txt \
        --normalPanel /home/jeszyman/repos/ichorCNA/inst/extdata/HD_ULP_PoN_1Mb_median_normAutosome_mapScoreFiltered_median.rds \
        --includeHOMD False --chrs "c(1:22)" --chrTrain "c(1:22)" \
        --estimateNormal True --estimatePloidy True --estimateScPrevalence True \
        --scStates "c(1,3)" --txnE 0.9999 --txnStrength 10000 --outDir ./

# low tumor vol
Rscript ~/repos/ichorCNA/scripts/runIchorCNA.R \
	--id tumor_sample \
        --WIG frag.wig \
	--normal "c(0.95, 0.99, 0.995, 0.999)" \
	--genomeBuild "hg38" \
        --ploidy "c(2)" --maxCN 3 \
        --gcWig ~/repos/ichorCNA/inst/extdata/gc_hg38_1000kb.wig \
        --mapWig ~/repos/ichorCNA/inst/extdata/map_hg38_1000kb.wig \
        --centromere ~/repos/ichorCNA/inst/extdata/GRCh38.GCA_000001405.2_centromere_acen.txt \
        --normalPanel ~/repos/ichorCNA/inst/extdata/HD_ULP_PoN_1Mb_median_normAutosome_mapScoreFiltered_median.rds \
        --includeHOMD False --chrs "c(1:22)" --chrTrain "c(1:22)" \
        --estimateNormal True --estimatePloidy True --estimateScPrevalence True \
        --scStates "c()" --txnE 0.9999 --txnStrength 10000 --outDir ./

  #+end_src

** Dockerfile
#+begin_src dockerfile :tangle ./Dockerfile
FROM rocker/r-ver:4.4.0

# Set environment variables
ENV DEBIAN_FRONTEND=noninteractive
ENV R_LIBS_USER=/usr/local/lib/R/site-library

# Install system dependencies including those needed for devtools
RUN apt-get update && apt-get install -y \
    git \
    curl \
    wget \
    libcurl4-openssl-dev \
    libssl-dev \
    libxml2-dev \
    libgit2-dev \
    libfontconfig1-dev \
    make \
    gcc \
    g++ \
    pandoc \
    zlib1g-dev \
    libharfbuzz-dev \
    libfribidi-dev \
    libudunits2-dev \
    libgdal-dev \
    libproj-dev \
    libgeos-dev && \
    apt-get clean && rm -rf /var/lib/apt/lists/*

# First, install basic packages with detailed output
RUN Rscript -e 'options(repos = c(CRAN = "https://cloud.r-project.org")); \
    install.packages("remotes"); \
    install.packages("BiocManager"); \
    install.packages("usethis"); \
    print(installed.packages()[,"Package"])'

# Install devtools with verbose output to see any errors
RUN Rscript -e 'options(repos = c(CRAN = "https://cloud.r-project.org")); \
    install.packages("devtools", dependencies=TRUE, verbose=TRUE); \
    print(installed.packages()[,"Package"])'

# Install additional required packages for ichorCNA
RUN Rscript -e 'options(repos = c(CRAN = "https://cloud.r-project.org")); \
    install.packages(c("optparse", "getopt", "tidyverse"))'

# Install Bioconductor packages
RUN Rscript -e 'BiocManager::install(version = "3.20", ask = FALSE); \
    BiocManager::install(c("GenomicFeatures", "AnnotationDbi", "biomaRt", "HMMcopy"), ask = FALSE)'

# Verify that devtools is installed and functioning
RUN Rscript -e 'library(devtools); sessionInfo()'

# Clone and install ichorCNA using remotes instead of devtools
RUN git clone https://github.com/broadinstitute/ichorCNA.git /opt/ichorCNA && \
    Rscript -e 'remotes::install_local("/opt/ichorCNA", dependencies = TRUE)'

# Install HMMcopy utils
RUN apt-get update && apt-get install -y cmake && \
    git clone https://github.com/shahcompbio/hmmcopy_utils.git /opt/hmmcopy_utils && \
    cd /opt/hmmcopy_utils && \
    cmake . && \
    make && \
    find bin -type f -executable -exec cp {} /usr/local/bin/ \; && \
    find util -type f -executable -exec cp {} /usr/local/bin/ \;

RUN Rscript -e 'BiocManager::install("BSgenome.Hsapiens.UCSC.hg38", update = FALSE)'

WORKDIR /data
ENTRYPOINT ["/bin/bash"]
#+end_src

#+begin_src bash
cd ~/repos/cfdna-cna
docker build -t ichor .
mkdir ~/sifs
apptainer build ~/sifs/ichor.sif docker-daemon://ichor:latest

#+end_src
#+begin_src bash
docker tag 460d842ba9db jeszyman/ichor:latest
docker login
docker push jeszyman/ichor:latest
#+end_src
** Workflows
- Snakemake
  #+begin_src snakemake :tangle ./workflows/test.smk
# import pandas as pd
# import os
# from tabulate import tabulate
# import sys


# ichor_bam_dir = config["ichor-bam-dir"]
# ichor_wig_dir = config["ichor-wig-dir"]
# ichor_out_main_dir = config["ichor-main-out-dir"]

# library_id = "NH_39_L1"


# rule all:
#     input:
#         expand(f"{ichor_out_main_dir}/{{library_id}}/{{library_id}}.cna.seg",
#                library_id=["NH_39_L1"]),


# Will follow symlinks
rule ichor_index_bam_check:
    input:
        bam = ancient(f"{ichor_bam_dir}/{{library_id}}.bam"),
    output:
        bai = f"{ichor_bam_dir}/{{library_id}}.bam.bai",
    shell:
        """
        samtools index -@ 8 {input.bam} {output.bai}
        """

rule make_wig:
    input:
        bam = f"{ichor_bam_dir}/{{library_id}}.bam",
        bai = f"{ichor_bam_dir}/{{library_id}}.bam.bai",
    output:
        wig = f"{ichor_wig_dir}/{{library_id}}.wig",
    params:
        window = "1000000",
        quality = 20,
    shell:
        """
        mkdir -p "{ichor_wig_dir}"
        readCounter \
        --window {params.window} \
        --quality {params.quality} \
	--chromosome "1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,X,Y" \
        {input} > {output}
        """

rule run_ichor:
    input:
        wig = f"{ichor_wig_dir}/{{library_id}}.wig"
    output:
        f"{ichor_out_main_dir}/{{library_id}}/{{library_id}}.cna.seg"
    params:
        ichor_out_main_dir = ichor_out_main_dir,
        ichor_repo = ichor_repo,
    shell:
        """
        Rscript {params.ichor_repo}/scripts/runIchorCNA.R \
        --id {wildcards.library_id} \
        --WIG {input.wig} \
        --normal "c(0.95, 0.99, 0.995, 0.999)" \
        --genomeBuild "hg38" \
        --ploidy "c(2)" \
        --gcWig {params.ichor_repo}/inst/extdata/gc_hg38_1000kb.wig \
        --mapWig {params.ichor_repo}/inst/extdata/map_hg38_1000kb.wig \
        --centromere {params.ichor_repo}/inst/extdata/GRCh38.GCA_000001405.2_centromere_acen.txt \
        --normalPanel {params.ichor_repo}/inst/extdata/HD_ULP_PoN_1Mb_median_normAutosome_mapScoreFiltered_median.rds \
        --includeHOMD False --chrs "c(1:22)" --chrTrain "c(1:22)" \
        --estimateNormal True --estimatePloidy True --estimateScPrevalence True \
        --scStates "c()" --txnE 0.9999 --txnStrength 10000 --outDir {params.ichor_out_main_dir}/{wildcards.library_id}
         """
#+end_src

** Setup and administration
*** Repository
#+begin_src bash
cd ~/repos/cfdna-cna
ls
mkdir -p tests/full-project/analysis/cna-wig
#+end_src
*** Git
- Add ichor
  #+begin_src bash
cd ~/repos/cfdna-cna
git clone git@github.com:broadinstitute/ichorCNA ichorCNA.v0.2.0
cd ichorCNA.v0.2.0
git fetch --depth 1 origin tag v0.2.0
git checkout tags/v0.2.0
#+end_src
*** Configuration
#+begin_src yaml :tangle ./config/test.yaml
ichor-bam-dir: /mnt/data/projects/breast/analysis/cna
ichor-wig-dir: /mnt/data/projects/breast/analysis/cna/wig
ichor-main-out-dir: /mnt/data/projects/breast/analysis/cna/ichor
#+end_src

**** Conda
- [[id:2fe724ad-3cd2-4598-aae2-38d468535fa7][Update conda env from github location yaml]]
***** ext-cfdna-cna environment
:properties:
:header-args:yaml: :tangle ./config/ext-cfdna-cna.yaml :comments no :mkdirp yes
:end:

- Inherits
  - https://raw.githubusercontent.com/jeszyman/basecamp/v1.0.0/basecamp_env.yaml
  - https://raw.githubusercontent.com/jeszyman/biotools/v1.0.0/biotools_env.yaml

#+begin_src yaml
# Conda environment for cell-free DNA copy number alteration analysis

#########1#########1#########1#########1#########1#########1#########1#########1


# Note:
#
# This environment is intended to extend my basic environments for computing
# and bioinformatics, which can be found in stable versions online:
#
# Basic computing at
# https://raw.githubusercontent.com/jeszyman/basecamp/v1.0.0/basecamp_env.yaml
#
# Bioinformatics at
# https://raw.githubusercontent.com/jeszyman/biotools/v1.0.0/biotools_env.yaml
#
# Run sequentially env update for basecamp, then biotools, then ext-cfdna-cna


name: cfdna-cna

channels:
  - conda-forge
  - bioconda

# Adding 'defaults' to channel list implicitly is deprecated and will be removed in 25.3.

dependencies:

  - bioconductor-hmmcopy
  # NOT hmmcopy
#+end_src

#+begin_src bash
cd ~/repos/cfdna-cna
conda activate base
conda create --name ext-cfdna-cna -y

curl -o /tmp/basecamp_env.yaml https://raw.githubusercontent.com/jeszyman/basecamp/v1.0.0/basecamp_env.yaml && mamba env update --name ext-cfdna-cna --file /tmp/basecamp_env.yaml

curl -o /tmp/biotools_env.yaml https://raw.githubusercontent.com/jeszyman/biotools/v1.0.0/biotools_env.yaml && mamba env update --name ext-cfdna-cna --file /tmp/biotools_env.yaml

mamba env update --name ext-cfdna-cna --file config/ext-cfdna-cna.yaml
#+end_src

*** [[file:config/int_test.yaml][Snakemake configuration YAML]]
#+begin_src bash :tangle ./config/int_test.yaml
container:
  cfdna_wgs: "~/sing_containers/cfdna_wgs.1.0.0.sif"
  default: "~/sing_containers/biotools.1.0.2.sif"

dir:
  cfdna_wgs_repo: "./"
  cfdna_wgs_scripts: "workflow/scripts"
  data: "test"

threads:
    default: "4"

#+end_src
*** Integration testing setup
#+begin_src bash
singularity shell --bind /mnt ~/sing_containers/cfdna_wgs.1.0.0.sif

# Clear bam directory if present
if [ -r test/bam ]; then \rm -rf test/bam; fi
mkdir -p test/bam

# Create small bam files to store in repo. Subsample real bams to ~100 Mb.
sambamba view -s .005 -f bam -t 36 /mnt/ris/aadel/mpnst/bam/lib070_dedup_sorted.bam > test/bam/lib001_hg19.bam
sambamba view -s .005 -f bam -t 36 /mnt/ris/aadel/mpnst/bam/lib054_dedup_sorted.bam > test/bam/lib002_hg19.bam
sambamba view -s .005 -f bam -t 36 /mnt/ris/aadel/mpnst/test/bam/new_HiSeq15_L002001_ACAC_extract_ds20.bam > test/bam/lib003_hg38.bam
sambamba view -s .005 -f bam -t 36 /mnt/ris/aadel/mpnst/test/bam/new_HiSeq15_L002001_ATCG_extract_ds20.bam > test/bam/lib004_hg38.bam

sambamba view -s 0.01 -f bam -t 4 /mnt/ris/aadel/mpnst/bam/cfdna_wgs/ds/lib105_ds10.bam > test/bam/lib005.bam
sambamba view -s 0.01 -f bam -t 4 /mnt/ris/aadel/mpnst/bam/cfdna_wgs/ds/lib205_ds10.bam > test/bam/lib006.bam



for file in test/bam/*.bam; do samtools index $file; done

#+end_src
** Methods
*** Filter alignment
#+begin_src bash
ssh jeff-ubuntu8
conda activate breast
cd /mnt/data/projects/breast/analysis/cna

THREADS=8
INPUT_BAM="NH_39_L1.bam"
BLACKLIST_BED="hg38-blacklist.v2.bed.gz"
OUTPUT_BAM="out.bam"

samtools view \
    --threads "$THREADS" \
    --output-fmt BAM \
    "$INPUT_BAM" \
    $(seq 1 22) | \
bedtools intersect \
    -abam - \
    -b "$BLACKLIST_BED" \
    -v | \
samtools view \
    --threads "$THREADS" \
    --output-fmt BAM \
    --min-MQ 30 \
    - > "$OUTPUT_BAM"

##########1##########2##########3##########4##########5##########6##########7##########8
INPUT="out.bam"
TARGET=5000
OUTPUT="ds.bam"

samtools index \
	 --threads 8 \
	 "$INPUT"

TOTAL=$(samtools idxstats "$INPUT" | awk '{sum += $3 + $4} END {print sum}')

FACTOR=$(echo "scale=8; $TARGET / $TOTAL" | bc)

if (( $(echo "$FACTOR > 1" | bc -l) )); then
    echo "[ERROR]: Requested number of reads exceeds total read count in $INPUT -- exiting"
    exit 1
fi

sambamba view -s "$FACTOR" -t 8 -f bam -l 5 "$INPUT" -o "$OUTPUT"

##########1##########2##########3##########4##########5##########6##########7##########8

INPUT_BAM="ds.bam"
OUTPUT_BAM="frag.bam"
LOWER=90
UPPER=150
THREADS=8

# Dynamically create temp names
HEADER_SAM="${OUTPUT_BAM%.bam}_header.sam"
BODY_SAM="${OUTPUT_BAM%.bam}_body.sam"

# Step 1: Extract header only
samtools view \
    --threads "$THREADS" \
    --header-only \
    "$INPUT_BAM" > "$HEADER_SAM"

# Step 2: Filter body (reads only)
samtools view \
    --threads "$THREADS" \
    --output-fmt SAM \
    "$INPUT_BAM" | \
awk -v lower="$LOWER" -v upper="$UPPER" '
    BEGIN { OFS="\t" }
    !/^@/ {
        tlen = ($9 < 0) ? -$9 : $9
        if (tlen > lower && tlen < upper)
            print
    }
' > "$BODY_SAM"

# Step 3: Concatenate header + filtered reads
cat "$HEADER_SAM" "$BODY_SAM" | \
samtools view \
    --threads "$THREADS" \
    --output-fmt BAM \
    - > "$OUTPUT_BAM"

# Step 4: Clean up
rm "$HEADER_SAM" "$BODY_SAM"


#+end_src

#+begin_src R
options(repos = c(CRAN = "https://cloud.r-project.org"))
install.packages("devtools")
install.packages("devtools", repos = "https://cloud.r-project.org", type = "source")

install.packages("devtools")
library(devtools)

if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install(c("S4Vectors", "IRanges", "XVector", "GenomeInfoDb", "GenomicRanges"))

#BiocManager::install("BSgenome.Hsapiens.UCSC.hg38")

#CANNOT PACKAGE INSTALL MUST CLONE
#install_github("broadinstitute/ichorCNA")

if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("GenomeInfoDb", version = "devel", force = TRUE)
BiocManager::install("GenomeInfoDb", version = "3.20", force = TRUE)




install.packages("optparse")

BiocManager::install("HMMcopy", force = T)

BiocManager::install("BSgenome.Hsapiens.UCSC.hg38")

#devtools::install_github(repo="Bioconductor/GenomeInfoDb")
BiocManager::install(version = "devel")
BiocManager::install("GenomeInfoDb", force = T)

#+end_src

#+begin_src bash
mamba install -n breast -c conda-forge r-devtools

mamba install -n breast -c bioconda bioconductor-bsgenome.hsapiens.ucsc.hg38

git clone https://github.com/broadinstitute/ichorCNA.git

mamba install -n breast -c conda-forge -c bioconda hmmcopy

samtools index frag.bam

readCounter \
    --window 1000000 \
    --quality 20 \
    --chromosome "1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,X,Y" \
    frag.bam > frag.wig


mamba install -n breast -c conda-forge -c bioconda r-optparse

mamba install -n breast -c conda-forge -c bioconda bioconductor-hmmcopy


cp -r ichorCNA ~/.conda/envs/breast/lib/R/library/

wget https://hgdownload.soe.ucsc.edu/goldenPath/hg19/database/chromInfo.txt.gz

wget https://hgdownload.soe.ucsc.edu/goldenPath/hg38/database/chromInfo.txt.gz


/usr/bin/Rscript ichorCNA/scripts/runIchorCNA.R --id tumor_sample \
  --WIG frag.wig --ploidy "c(2,3)" --normal "c(0.5,0.6,0.7,0.8,0.9)" --maxCN 5 \
  --gcWig ichorCNA/inst/extdata/gc_hg38_1000kb.wig \
  --mapWig ichorCNA/inst/extdata/map_hg38_1000kb.wig \
  --centromere ichorCNA/inst/extdata/GRCh38.GCA_000001405.2_centromere_acen.txt \
  --normalPanel ichorCNA/inst/extdata/HD_ULP_PoN_1Mb_median_normAutosome_mapScoreFiltered_median.rds \
  --includeHOMD False --chrs "c(1:22)" --chrTrain "c(1:22)" \
  --estimateNormal True --estimatePloidy True --estimateScPrevalence True \
  --genomeBuild hg38 --scStates "c(1,3)" --txnE 0.9999 --txnStrength 10000 --outDir ./
#+end_src

*** Fragment size filtering
#+begin_src bash
conda activate breast
cd cna
ls


samtools index NH_39_L1.bam

samtools idxstats NH_39_L1.bam


# The output is TAB-delimited with each line consisting of reference sequence name, sequence length, # mapped read-segments and # unmapped read-segments.


##########1##########2##########3##########4##########5##########6##########7##########8


samtools index \
	 --bai \
	 --threads 10 \


#+end_src


- snakemake
  #+begin_src snakemake
rule frag_filt:
    input:
        cfdna_wgs_cna_bam_inputs + "/{library}.bam",
    params:
        script = cfdna_wgs_scripts + "/frag_filt.sh",
    output:
        nohead =   temp(cfdna_wgs_cna_bam_fragfilt + "/{library}_frag{frag_distro}.nohead"),
        onlyhead = temp(cfdna_wgs_cna_bam_fragfilt + "/{library}_frag{frag_distro}.onlyhead"),
        final =         cfdna_wgs_cna_bam_fragfilt + "/{library}_frag{frag_distro}.bam",
    container:
        cfdna_wgs_container
    shell:
        """
        frag_min=$(echo {wildcards.frag_distro} | sed -e "s/_.*$//g")
        frag_max=$(echo {wildcards.frag_distro} | sed -e "s/^.*_//g")
        {params.script} \
        {input} \
        {output.nohead} \
        $frag_min \
        $frag_max \
        {config[threads]} \
        {output.onlyhead} \
        {output.final}
        """
#+end_src
- shell
  #+begin_src bash :tangle ./workflow/scripts/frag_filt.sh

# Steps
## Filter by absolute value of TLEN for each read
sambamba view -t $5 $1 | awk -F'\t' -v upper="$4" 'sqrt($9*$9) < upper {print $0}' | awk -F'\t' -v lower="$3" 'sqrt($9*$9) > lower {print $0}'> $2

## Restore header
sambamba view -H $1 > $6

cat $6 $2 | sambamba view -t 4 -S -f bam /dev/stdin | sambamba sort -t 4 -o $7 /dev/stdin

#+end_src
*** DONE Convert bam to wig
#+begin_src bash
cd ~/repos/cfdna-cna
conda activate ext-cfdna-cna

sed 's/^fixedStep chrom=chr\([0-9XYM]\+\)/fixedStep chrom=\1/' tests/wigs/test.wig > tests/wigs/test_ncbi.wig


Rscript ./ichorCNA.v0.2.0/scripts/runIchorCNA.R \
         --id TEST \
         --WIG ./tests/wigs/test_ncbi.wig \
         --gcWig ./ichorCNA.v0.2.0/inst/extdata/gc_hg38_1000kb.wig \
         --mapWig ./ichorCNA.v0.2.0/inst/extdata/map_hg38_1000kb.wig \
         --centromere ./ichorCNA.v0.2.0/inst/extdata/GRCh38.GCA_000001405.2_centromere_acen.txt \
         --normal "c(0.95, 0.99, 0.995, 0.999)" \
         --normalPanel ./ichorCNA.v0.2.0/inst/extdata/HD_ULP_PoN_1Mb_median_normAutosome_mapScoreFiltered_median.rds \
         --ploidy "c(2)" \
         --maxCN 3 \
         --estimateScPrevalence FALSE \
         --scStates "c()" \
         --outDir ./test/ichor \
	 --libdir ./ichorCNA.v0.2.0 \
	 --genomeStyle "NCBI"
#+end_src

#+begin_src snakemake
rule bam_to_wig:
    input:
        cfdna_wgs_cna_bam_fragfilt + "/{library}_frag{frag_distro}.bam",
    output:
        wig + "/{library}_frag{frag_distro}.wig",
    params:
        chrs = "chr1,chr2,chr3,chr4,chr5,chr6,chr7,chr8,chr9,chr10,chr11,chr12,chr13,chr14,chr15,chr16,chr17,chr18,chr19,chr20,chr21,chr22,chrX,chrY"
    container:
        cfdna_wgs_container,
    shell:
        """
        /opt/hmmcopy_utils/bin/readCounter --window 1000000 --quality 20 \
        --chromosome {params.chrs} \
        {input} > {output}
        """
#+end_src

*** DONE Make list of wigs from normals                            :smk_rule:
- Snakemake
  #+begin_src snakemake
# Make ichorCNA panel of normals from healthy samples
rule pon_list:
    input:
        expand(wig + "/{library}_frag{frag_distro}.wig", library = NORMAL_LIBRARIES, frag_distro = ["90_150"]),
    output:
        wig + "/normal.txt",
    log:
        cfdna_wgs_logs + "/pon.log",
    container:
        cfdna_wgs_container,
    shell:
        """
        input_string=$(echo "{input}" | tr " " "\n")
        if [ -f {output} ]; then rm {output}; fi
        echo -e "${{input_string}}" >> {output}
        """
#+end_src
*** DONE Make panel of normals                                     :smk_rule:
- Snakemake
  #+begin_src snakemake
# Make ichorCNA panel of normals from healthy samples
rule pon:
    input:
        wig + "/normal.txt",
    params:
        script = cfdna_wgs_scripts + "/pon.sh",
	outdir = wig
    output:
        wig + "/pon_median.rds"
    log:
        cfdna_wgs_logs + "/pon.log",
    container:
        cfdna_wgs_container,
    shell:
        """
        {params.script} \
        {input} \
        {params.outdir} &> {log}
        """
#+end_src
- [[file:./workflow/scripts/pon.sh][Shell script]]
  #+begin_src bash :tangle ./workflow/scripts/pon.sh
#!/usr/bin/env bash
filelist=$1
out_dir=$2

Rscript /opt/ichorCNA/scripts/createPanelOfNormals.R --filelist $filelist \
        --chrs "paste0('chr', c(1:22, \"X\"))" \
        --chrNormalize "c(1:22, \"X\")" \
        --gcWig /opt/ichorCNA/inst/extdata/gc_hg38_1000kb.wig \
        --mapWig /opt/ichorCNA/inst/extdata/map_hg38_1000kb.wig \
        --centromere /opt/ichorCNA/inst/extdata/GRCh38.GCA_000001405.2_centromere_acen.txt  \
        --outfile "${out_dir}/pon"

#+end_src
*** DONE Run ichor
#+begin_src snakemake
rule ichor:
    input:
        wig = wig + "/{library}_frag{frag_distro}.wig",
	pon = wig + "/pon_median.rds",
    output:
        ichor + "/{library}_frag{frag_distro}.cna.seg",
    params:
        script = cfdna_wgs_scripts + "/MOD_runIchorCNA.R",
        out_dir = ichor,
    container:
        cfdna_wgs_container,
    shell:
        """
        Rscript {params.script} \
         --id {wildcards.library}_frag{wildcards.frag_distro} \
         --WIG {input.wig} \
         --gcWig /opt/ichorCNA/inst/extdata/gc_hg38_1000kb.wig \
         --mapWig /opt/ichorCNA/inst/extdata/map_hg38_1000kb.wig \
         --centromere /opt/ichorCNA/inst/extdata/GRCh38.GCA_000001405.2_centromere_acen.txt \
         --normal "c(0.95, 0.99, 0.995, 0.999)" \
         --normalPanel {input.pon} \
         --ploidy "c(2)" \
         --maxCN 3 \
         --estimateScPrevalence FALSE \
         --scStates "c()" \
         --outDir {params.out_dir}
        """
#+end_src
- Testing
  - hg38 test
    #+begin_src bash
  # mkdir /tmp/ichor_out
  # singularity shell ~/sing_containers/mpnst.sif

  Rscript /opt/ichorCNA/scripts/runIchorCNA.R --id tumor_sample \
  --WIG /tmp/test.wig --ploidy "c(2,3)" --normal "c(0.5,0.6,0.7,0.8,0.9)" --maxCN 5 \
  --gcWig /opt/ichorCNA/inst/extdata/gc_hg38_1000kb.wig \



  --includeHOMD False --chrs "c(1:22, \"X\")" --chrTrain "c(1:22)" \
  --estimateNormal True --estimatePloidy True --estimateScPrevalence True \
  --scStates "c(1,3)" --txnE 0.9999 --txnStrength 10000 --outDir /tmp/ichor_out
  #+end_src
  - works
    - hg19
      #+begin_src bash
  #mkdir -p /tmp/ichor_out
  #singularity shell ~/sing_containers/mpnst.sif

  # Notes
  ##
  ## Will overwrite target files with a warning
  ##
  ##


  Rscript /opt/ichorCNA/scripts/runIchorCNA.R --id tumor_sample \
    --WIG ~/repos/cfdna-cna/test/wig/lib002_hg19_frag90_150.wig --ploidy "c(2,3)" --normal "c(0.5,0.6,0.7,0.8,0.9)" --maxCN 5 \
    --gcWig /opt/ichorCNA/inst/extdata/gc_hg19_1000kb.wig \
    --mapWig /opt/ichorCNA/inst/extdata/map_hg19_1000kb.wig \
    --centromere /opt/ichorCNA/inst/extdata/GRCh37.p13_centromere_UCSC-gapTable.txt \
    --normalPanel /opt/ichorCNA/inst/extdata/HD_ULP_PoN_1Mb_median_normAutosome_mapScoreFiltered_median.rds \
    --includeHOMD False --chrs "c(1:22, \"X\")" --chrTrain "c(1:22)" \
    --estimateNormal True --estimatePloidy True --estimateScPrevalence True \
    --scStates "c(1,3)" --txnE 0.9999 --txnStrength 10000 --outDir /tmp/ichor_out
  #+end_src
      #+begin_src bash
  # mkdir /tmp/ichor_out
  # singularity shell ~/sing_containers/mpnst.sif

  Rscript ./workflow/scripts/MOD_runIchorCNA.R --id tumor_sample \
    --WIG ~/repos/cfdna-cna/test/wig/lib002_frag90_150.wig --ploidy "c(2,3)" --normal "c(0.5,0.6,0.7,0.8,0.9)" --maxCN 5 \
    --gcWig /opt/ichorCNA/inst/extdata/gc_hg19_1000kb.wig \
    --mapWig /opt/ichorCNA/inst/extdata/map_hg19_1000kb.wig \
    --centromere /opt/ichorCNA/inst/extdata/GRCh37.p13_centromere_UCSC-gapTable.txt \
    --normalPanel /opt/ichorCNA/inst/extdata/HD_ULP_PoN_1Mb_median_normAutosome_mapScoreFiltered_median.rds \
    --includeHOMD False --chrs "c(1:22, \"X\")" --chrTrain "c(1:22)" \
    --estimateNormal True --estimatePloidy True --estimateScPrevalence True \
    --scStates "c(1,3)" --txnE 0.9999 --txnStrength 10000 --outDir /tmp/ichor_out
  #+end_src
      - running an old hg19
        #+begin_src bash
      Rscript /opt/ichorCNA/scripts/runIchorCNA.R --id tumor_sample \
        --WIG /tmp/test_hg19.wig --ploidy "c(2,3)" --normal "c(0.5,0.6,0.7,0.8,0.9)" --maxCN 5 \
        --gcWig /opt/ichorCNA/inst/extdata/gc_hg19_1000kb.wig \
        --mapWig /opt/ichorCNA/inst/extdata/map_hg19_1000kb.wig \
        --centromere /opt/ichorCNA/inst/extdata/GRCh37.p13_centromere_UCSC-gapTable.txt \
        --normalPanel /opt/ichorCNA/inst/extdata/HD_ULP_PoN_1Mb_median_normAutosome_mapScoreFiltered_median.rds \
        --includeHOMD False --chrs "c(1:22, \"X\")" --chrTrain "c(1:22)" \
        --estimateNormal True --estimatePloidy True --estimateScPrevalence True \
        --scStates "c(1,3)" --txnE 0.9999 --txnStrength 10000 --outDir /tmp/ichor_out_test
      #+end_src
  - d
    #+begin_src bash
  Rscript workflow/scripts/MOD_runIchorCNA.R --id lib003_hg38_frag90_150 \
          --WIG test/wig/lib003_hg38_frag90_150.wig \
          --gcWig /opt/ichorCNA/inst/extdata/gc_hg38_1000kb.wig \
          --mapWig /opt/ichorCNA/inst/extdata/map_hg38_1000kb.wig \
          --centromere /opt/ichorCNA/inst/extdata/GRCh38.GCA_000001405.2_centromere_acen.txt \
          --normal "c(0.95, 0.99, 0.995, 0.999)" \
          --ploidy "c(2)" \
          --maxCN 3 \
          --estimateScPrevalence FALSE \
          --scStates "c()" \
          --outDir test/ichor_hg38



          # --normalPanel /opt/ichorCNA/inst/extdata/HD_ULP_PoN_hg38_1Mb_median_normAutosome_median.rds \
  #                                                   HD_ULP_PoN_hg38_1Mb_median_normAutosome_median.rds
  #+end_src
- Notes: Fails when extdata PoN specified
#+begin_src R

#+end_src

*** TODO Run ichor no PON
#+begin_src snakemake
rule ichor_nopon:
    input:
        wig = wig + "/{library}_frag{frag_distro}.wig",
	pon = wig + "/pon_median.rds",
    output:
        ichor_nopon + "/{library}_frag{frag_distro}.cna.seg",
    params:
        script = cfdna_wgs_scripts + "/MOD_runIchorCNA.R",
        out_dir = ichor_nopon,
    container:
        cfdna_wgs_container,
    shell:
        """
        Rscript {params.script} \
         --id {wildcards.library}_frag{wildcards.frag_distro} \
         --WIG {input.wig} \
         --gcWig /opt/ichorCNA/inst/extdata/gc_hg38_1000kb.wig \
         --mapWig /opt/ichorCNA/inst/extdata/map_hg38_1000kb.wig \
         --centromere /opt/ichorCNA/inst/extdata/GRCh38.GCA_000001405.2_centromere_acen.txt \
         --normal "c(0.95, 0.99, 0.995, 0.999)" \
         --ploidy "c(2)" \
         --maxCN 3 \
         --estimateScPrevalence FALSE \
         --scStates "c()" \
         --outDir {params.out_dir}
        """
#+end_src

*** dev                                                                 :dev:
:PROPERTIES:
:header-args:snakemake: :tangle no
:END:
- testing
  #+begin_src bash
#singularity shell --bind /mnt:/mnt ~/sing_containers/mpnst.sif


/opt/hmmcopy_utils/bin/readCounter \
 --window 1000000 \
 --quality 20 \
 --chromosome "chr1,chr2,chr3,chr4,chr5,chr6,chr7,chr8,chr9,chr10,chr11,chr12,chr13,chr14,chr15,chr16,chr17,chr18,chr19,chr20,chr21,chr22,chrX" \
 ~/repos/cfdna-cna/test/bam/lib004_hg38.bam > /tmp/test.wig

#+end_src
**** Run hg19 ichor
#+begin_src snakemake
rule hg19_ichor:
    input:
        config["wig_dir"] + "/{library_id}_frag{frag_distro}.wig",
    output:
        config["ichor_hg19_dir"] + "/{library_id}_frag{frag_distro}.cna.seg",
    shell:
        """
        Rscript {config[cfdna_cna_repo]}/workflow/scripts/MOD_runIchorCNA.R \
         --id {wildcards.library_id}_frag{wildcards.frag_distro} \
         --WIG {input} \
         --gcWig /opt/ichorCNA/inst/extdata/gc_hg19_1000kb.wig \
         --normal "c(0.95, 0.99, 0.995, 0.999)" \
         --ploidy "c(2)" \
         --maxCN 3 \
         --estimateScPrevalence FALSE \
         --scStates "c()" \
         --outDir {config[ichor_hg19_dir]}
        """
#+end_src
** Testing
*** INPROCESS Integration testing                                       :smk:
:PROPERTIES:
:header-args:snakemake: :tangle ./workflow/int_test.smk
:END:
**** Preamble, path declarations, functions, etc.
#+begin_src snakemake :tangle ./workflow/int_test.smk
#container: config["container"]

LIBRARIES = ["lib003",
	     "lib004",
	     "lib005",
	     "lib006"]

NORMAL_LIBRARIES = ["lib003", "lib004"]

cfdna_wgs_container = config["container"]["cfdna_wgs"]
cfdna_wgs_scripts = config["dir"]["cfdna_wgs_repo"] + "/workflow/scripts"

cfdna_wgs_cna_bam_inputs   = config["dir"]["data"] + "/bam/filt"
cfdna_wgs_cna_bam_fragfilt = config["dir"]["data"] + "/bam/frag"

wig = config["dir"]["data"] + "/wig"
ichor = config["dir"]["data"] + "/ichor"
cfdna_wgs_logs = config["dir"]["data"] + "logs/cfdna_wgs"
ichor_nopon = config["dir"]["data"] + "/ichor_nopon"
#+end_src
**** All rule
#+begin_src snakemake :tangle ./workflow/int_test.smk
rule all:
    input:
	# Fragment-filtered bam
        #expand(cfdna_wgs_cna_bam_fragfilt + "/{library}_frag{frag_distro}.bam", library = LIBRARIES, frag_distro = ["90_150"]),
	# Wiggle
        #expand(wig + "/{library}_frag{frag_distro}.wig", library = LIBRARIES, frag_distro = ["90_150"]),
        # PoN list
        #wig + "/normal.txt",
        # PoN
        #wig + "/pon_median.rds",
	# Ichor
        expand(ichor + "/{library}_frag{frag_distro}.cna.seg", library = LIBRARIES, frag_distro = ["90_150"]),
        expand(ichor_nopon + "/{library}_frag{frag_distro}.cna.seg", library = LIBRARIES, frag_distro = ["90_150"]),
#+end_src
**** Includes
#+begin_src snakemake
include: "cfdna_wgs_cna.smk"
#+end_src
** Reference
** Ideas
- window size vs tumor fraction optimization
- biocparallel? for ichor sections
- https://mail.google.com/mail/u/0/#inbox/FMfcgzGmtrMStSdxMHbXDpqGDVTrjMpl
- ichor PON
- extract tf
  tfRAW = as_tibble(read.table(file.path(repo,"data/tf_summary"), header = F, sep = '\t'))

target_cnaRAW = as_tibble(read.table(file.path(repo,"data/target_cna.bed"), sep = '\t', header = F))

taylor_washoutRAW = as_tibble(read.csv(file.path(repo, "data/cfDNA PN and MPNST washout libraries for ROC.csv"), header = T))

coverageRAW = as_tibble(read.table(file.path(repo,"data/all_dedup_coverage.tsv"), sep='\t', header = T))

librariesRAW = as_tibble(
  read.csv(file.path(repo,"data/library_index.csv"), header = T)
)

washout_libs = as_tibble(
read.csv(file.path(repo,"data/washout_libs.csv"), header = T)
)

specimensRAW = as_tibble(
  read.csv(file.path(repo,"data/specimen_index.csv"), header = T)
  )

subjectsRAW = as_tibble(
  read.csv(file.path(repo, "data/subject_index.csv"), header = T)
  )

  #+begin_src R
library(tidyverse)

load("/mnt/ris/aadel/mpnst/data_model/data_model.RData")

ls()

names(libraries_full)

class(libraries_full$collect_date)

libraries_full$collect_date = as.Date(libraries_full$collect_date)

as.numeric(libraries_full$collect_date[[1]]- libraries_full$collect_date[[2]])

test =
  libraries_full %>% arrange(collect_date) %>% group_by(participant_id, isolation_type) %>%
  mutate(collect_day = as.numeric(collect_date - first(collect_date))) %>%
  mutate(collect_day = replace_na(collect_day, 0))

tf = read.table("/tmp/tf.tsv", header = F, sep = '\t')
colnames(tf) = c("libnfrag", "tf", "ploidy")
tf$library_id = substr(tf$libnfrag, 1, 6)

tf2 =
  tf %>% filter(grepl("sub20m_frag90", libnfrag))


test2=tf2 %>% left_join(test, by = "library_id")

write.csv(file ="/tmp/test.csv", test2)
test %>% select(participant_id, collect_day) %>% arrange(participant_id) %>% print(n = Inf)



test$collect_day

  case_when(collect_date == first(collect_date) ~ 0,
                                 collect_date > first(collect_date) ~ collect_date - first(collect_date)))




) %>% select(library_id, participant_id, collect_day)
#+end_src
*** Dev
:PROPERTIES:
:header-args:snakemake: :tangle no
:END:
**** Aggregate ichor
**** CN LOH
https://github.com/mskcc/facets
https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5027494/
- a CN LOH call is NOT available in ichor, is in titanCNA
- FACETS is used for CN-LOH in cfDNA- https://aacrjournals.org/clincancerres/article/28/3/526/678032/Activation-of-PI3K-AKT-Pathway-Is-a-Potential

  https://sites.google.com/site/mskfacets/
;https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6267593/

facets for independent ichor confirm? https://github.com/mskcc/facets/issues/72
ichor does cn loh calls- check out
*** ichorCNA optimization
https://raw.githubusercontent.com/Boyle-Lab/Blacklist/master/lists/hg38-blacklist.v2.bed.gz

ichorCNA goes looking for chromInfo.txt.gz from UCSC only when it cannot infer chromosome sizes from the input data. Specifically, this happens inside wigToGRanges() → getSeqInfo() when:
- The --WIG input file lacks valid or complete chromosome names, or
- The chromosomes in the .wig don't match the expected genome (--genomeBuild), or
- The .wig only includes partial chromosomes, e.g., only chrM or chr1, and not 1–22,X,Y, or
- The expected UCSC-style sequence info is not preloaded into the environment

- remove dependency pulls
#+begin_src R
getwd()
setwd("/home/jeszyman/repos/cfdna-cna")

libdir="../ichorCNA"

## load ichorCNA library or source R scripts
if (!is.null(libdir) && libdir != "None"){
	source(paste0(libdir,"/R/utils.R"))
	source(paste0(libdir,"/R/segmentation.R"))
	source(paste0(libdir,"/R/EM.R"))
	source(paste0(libdir,"/R/output.R"))
	source(paste0(libdir,"/R/plotting.R"))
} else {
    library(ichorCNA)
}


tumour_file="/mnt/data/projects/cfdna-cna/lib003_frag90_150.wig"
patientID = "pat"

# This is checking if it's a wig or a dir
if (substr(tumour_file,nchar(tumour_file)-2,nchar(tumour_file)) == "wig") {
  wigFiles <- data.frame(cbind(patientID, tumour_file))
} else {
  wigFiles <- read.delim(tumour_file, header=F, as.is=T)
}

ls()

wigFiles
exons.bed=NULL

## FILTER BY EXONS IF PROVIDED ##
## add gc and map to GRanges object ##
if (is.null(exons.bed) || exons.bed == "None" || exons.bed == "NULL"){
  targetedSequences <- NULL
}else{
  targetedSequences <- read.delim(exons.bed, header=T, sep="\t")
}

normal_panel = NULL

centromere = "../ichorCNA/inst/extdata/GRCh38.GCA_000001405.2_centromere_acen.txt"

outImage = "/tmp/test-ichor"

## load PoN
if (is.null(normal_panel) || normal_panel == "None" || normal_panel == "NULL"){
	normal_panel <- NULL
}

if (is.null(centromere) || centromere == "None" || centromere == "NULL"){ # no centromere file provided
	centromere <- system.file("extdata", "GRCh37.p13_centromere_UCSC-gapTable.txt",
			package = "ichorCNA")
}

centromere <- read.delim(centromere,header=T,stringsAsFactors=F,sep="\t")

save.image(outImage)

outDir = "/tmp/ichor2"

## LOAD IN WIG FILES ##
(numSamples <- nrow(wigFiles))

tumour_copy <- list()

library(GenomicRanges)

wigToGRanges <- function(wigfile, verbose = TRUE){
  if (verbose) { message(paste("Slurping:", wigfile)) }
  input <- readLines(wigfile, warn = FALSE)
  breaks <- c(grep("fixedStep", input), length(input) + 1)
  temp <- NULL
  span <- NULL
  for (i in 1:(length(breaks) - 1)) {
    data_range <- (breaks[i] + 1):(breaks[i + 1] - 1)
    track_info <- input[breaks[i]]
    if (verbose) { message(paste("Parsing:", track_info)) }
    tokens <- strsplit(
      sub("fixedStep chrom=(\\S+) start=(\\d+) step=(\\d+) span=(\\d+)",
          "\\1 \\2 \\3 \\4", track_info, perl = TRUE), " ")[[1]]
    span <- as.integer(tokens[4])
    chr <- rep(tokens[1], length(data_range))
    pos <- seq(from = as.integer(tokens[2]), by = as.integer(tokens[3]),
               length.out = length(data_range))
    val <- as.numeric(input[data_range])
    temp <- c(temp, list(data.frame(chr, pos, val)))
  }
  if (verbose) { message("Sorting by decreasing chromosome size") }
  lengths <- as.integer(lapply(temp, nrow))
  temp <- temp[order(lengths, decreasing = TRUE)]
  temp = do.call("rbind", temp)
  output <- GenomicRanges::GRanges(ranges = IRanges(start = temp$pos, width = span),
                       seqnames = temp$chr, value = temp$val)
  return(output)
}

gcWig = "../ichorCNA/inst/extdata/gc_hg38_1000kb.wig"
mapWig = NULL

library(HMMcopy)
library(GenomeInfoDb)


counts= tumour_reads
(chrs = c(1:22, "X", "Y"))
(chrs = c("chr1", "chr2"))

flankLength = 100000

targetedSequences = NULL

genomeStyle = "UCSC"

mapScoreThres = 0.9

applyCorrection = F

#filterByMappabilityScore <- function(counts, map, mapScoreThres = 0.9){
message("Filtering low uniqueness regions with mappability score < ", mapScoreThres)
counts <- counts[counts$map >= mapScoreThres, ]


#loadReadCountsFromWig <- function(counts, chrs = c(1:22, "X", "Y"), gc = NULL, map = NULL, centromere = NULL, flankLength = 100000, targetedSequences = NULL, genomeStyle = "NCBI", applyCorrection = TRUE, mapScoreThres = 0.9, chrNormalize = c(1:22, "X", "Y"), fracReadsInChrYForMale = 0.002, chrXMedianForMale = -0.5, useChrY = TRUE){
require(HMMcopy)
require(GenomeInfoDb)


counts.raw <- counts
counts <- keepChr(counts, chrs)

if (!is.null(gc)){
  counts$gc <- keepChr(gc, chrs)$value
}
if (!is.null(map)){
  counts$map <- keepChr(map, chrs)$value
}
colnames(values(counts))[1] <- c("reads")


# remove centromeres
if (!is.null(centromere)){
  counts <- excludeCentromere(counts, centromere, flankLength = flankLength, genomeStyle=genomeStyle)
}

# keep targeted sequences
if (!is.null(targetedSequences)){
  colnames(targetedSequences)[1:3] <- c("chr", "start", "end")
  targetedSequences.GR <- as(targetedSequences, "GRanges")
  countsExons <- filterByTargetedSequences(counts, targetedSequences.GR)
  counts <- counts[countsExons$ix,]
}

gender <- NULL

if (applyCorrection){
  ## correct read counts ##

  counts <- correctReadCounts(counts, chrNormalize = chrNormalize)
  if (!is.null(map)) {
    ## filter bins by mappability
    counts <- filterByMappabilityScore(counts, map=map, mapScoreThres = mapScoreThres)
  }
}


return(list(counts = counts, gender = gender))


test = loadReadCountsFromWig(tumour_reads, chrs = c("chr1","chr2"))

test = loadReadCountsFromWig(tumour_reads, chrs = c("1","2"))

tumour_reads

genomeStyle
seqlevelsStyle(chrs) = genomeStyle
seqlevelsStyle(chrNormalize) = genomeStyle
seqlevelsStyle(chrTrain) = genomeStyle

normal_file = NULL

normalizeMaleX = FALSE

#########1#########2#########3#########4#########5#########6#########7#########8
tumour_copy <- list()

results_list = list()

for (i in 1:numSamples) {
  id <- wigFiles[i,1]
  ## create output directories for each sample ##
  dir.create(paste0(outDir, "/", id, "/"), recursive = TRUE)
  ### LOAD TUMOUR AND NORMAL FILES ###
  message("Loading tumour file:", wigFiles[i,1])
  tumour_reads <- wigToGRanges(wigFiles[i,2])

  ## LOAD GC/MAP WIG FILES ###
  # find the bin size and load corresponding wig files #
  binSize <- as.data.frame(tumour_reads[1,])$width
  message("Reading GC and mappability files")
  if (is.null(gcWig) || gcWig == "None" || gcWig == "NULL"){
      stop("GC wig file is required")
  }
  gc <- wigToGRanges(gcWig)
  if (is.null(mapWig) || mapWig == "None" || mapWig == "NULL"){
      message("No mappability wig file input, excluding from correction")
      map <- NULL
  } else {
      map <- wigToGRanges(mapWig)
  }
  message("Correcting Tumour")

  ## counts <- loadReadCountsFromWig(tumour_reads, chrs = chrs, gc = gc, map = map,
  ##                                 centromere = centromere, flankLength = flankLength,
  ##                                 targetedSequences = targetedSequences, chrXMedianForMale = chrXMedianForMale,
  ##                                 genomeStyle = genomeStyle, fracReadsInChrYForMale = fracReadsInChrYForMale,
  ##                                 chrNormalize = chrNormalize, mapScoreThres = minMapScore)

  counts <- loadReadCountsFromWig(tumour_reads, chrs = chrs, gc = gc, genomeStyle = "UCSC", applyCorrection = F)


  tumour_copy[[id]] <- counts$counts #as(counts$counts, "GRanges")
  gender <- counts$gender

  normal_file = NULL

  #########1#########2#########3#########4#########5#########6#########7#########8
  if (!is.null(normal_file) && normal_file != "None" && normal_file != "NULL"){
	message("Loading normal file:", normal_file)
	normal_reads <- wigToGRanges(normal_file)
	message("Correcting Normal")
	counts <- loadReadCountsFromWig(normal_reads, chrs=chrs, gc=gc, map=map,
			centromere=centromere, flankLength = flankLength, targetedSequences=targetedSequences,
			genomeStyle = genomeStyle, chrNormalize = chrNormalize, mapScoreThres = minMapScore)
	normal_copy <- counts$counts #as(counts$counts, "GRanges")
	gender.normal <- counts$gender
  }else{
	normal_copy <- NULL
  }

  #########1#########2#########3#########4#########5#########6#########7#########8

    ### DETERMINE GENDER ###
  ## if normal file not given, use chrY, else use chrX
  message("Determining gender...", appendLF = FALSE)
  gender.mismatch <- FALSE
  if (!is.null(normal_copy)){
	if (gender$gender != gender.normal$gender){ #use tumour # use normal if given
	# check if normal is same gender as tumour
	  gender.mismatch <- TRUE
	}
  }
  message("Gender ", gender$gender)

  #########1#########2#########3#########4#########5#########6#########7#########8
 ## NORMALIZE GENOME-WIDE BY MATCHED NORMAL OR NORMAL PANEL (MEDIAN) ##
  tumour_copy[[id]] <- normalizeByPanelOrMatchedNormal(tumour_copy[[id]], chrs = chrs,
      normal_panel = normal_panel, normal_copy = normal_copy,
      gender = gender$gender, normalizeMaleX = normalizeMaleX)

	### OUTPUT FILE ###
	### PUTTING TOGETHER THE COLUMNS IN THE OUTPUT ###
	outMat <- as.data.frame(tumour_copy[[id]])
	#outMat <- outMat[,c(1,2,3,12)]
	#outMat <- outMat[,c("seqnames","start","end","copy")]
	#colnames(outMat) <- c("chr","start","end","log2_TNratio_corrected")
	#outFile <- paste0(outDir,"/",id,".correctedDepth.txt")
	#message(paste("Outputting to:", outFile))
  #write.table(outMat, file=outFile, row.names=F, col.names=T, quote=F, sep="\t")
    # Process and generate outMat

  # Store in results list
  results_list[[id]] <- outMat
}

assign("outMat_results", results_list, envir = .GlobalEnv)


#########1#########2#########3#########4#########5#########6#########7#########8
#normalizeByPanelOrMatchedNormal <- function(tumour_copy, chrs = c(1:22, "X", "Y"),
#normal_panel = NULL, normal_copy = NULL, gender = "female", normalizeMaleX = FALSE){

genomeStyle <- seqlevelsStyle(tumour_copy)[1]
seqlevelsStyle(chrs) <- genomeStyle


### COMPUTE LOG RATIO FROM MATCHED NORMAL OR PANEL AND HANDLE CHRX ###
	## NO PANEL
	# matched normal but NO panel, then just normalize by matched normal (WES)
	## WHY DO WE NOT NORMALIZE BY NORMAL WITH PANEL? ##
chrXInd <- grep("X", as.character(seqnames(tumour_copy)))

	chrXMedian <- median(tumour_copy[chrXInd, ]$copy, na.rm = TRUE)
	if (!is.null(normal_copy) && is.null(normal_panel)){
			message("Normalizing Tumour by Normal")
			tumour_copy$copy <- tumour_copy$copy - normal_copy$copy
			rm(normal_copy)
	}
	# matched normal and panel and male, then compute normalized chrX median (WES)
	if (!is.null(normal_copy) && !is.null(normal_panel) && gender=="male"){
			message("Normalizing by matched normal for ChrX")
			chrX.MNnorm <- tumour_copy$copy[chrXInd] - normal_copy$copy[chrXInd]
			chrXMedian.MNnorm <- median(chrX.MNnorm, na.rm = TRUE)
	}
	# if male, then just normalize chrX to median (ULP and WES)
	if (is.null(normal_copy) && gender=="male" && !gender.mismatch && normalizeMaleX){
			tumour_copy$copy[chrXInd] <- tumour_copy$copy[chrXInd] - chrXMedian
	}
	# PANEL, then normalize by panel instead of matched normal (ULP and WES)
	if (!is.null(normal_panel)){
		## load in IRanges object, then convert to GRanges
		panel <- readRDS(normal_panel)
		seqlevelsStyle(panel) <- genomeStyle
		panel <- keepChr(panel, chr = chrs)
        # intersect bins in sample and panel
        hits <- findOverlaps(tumour_copy, panel, type="equal")
        tumour_copy <- tumour_copy[queryHits(hits),]
        panel <- panel[subjectHits(hits),]
        # subtract out panel median
		tumour_copy$copy <- tumour_copy$copy - panel$Median
		# if male, then shift chrX by +chrXMedian.MNnorm
		if (gender == "male" && exists("chrXMedian.MNnorm")){
			tumour_copy$copy[chrXInd] <- tumour_copy$copy[chrXInd] + chrXMedian.MNnorm
		}
	}
	return(tumour_copy)
}


#########1#########2#########3#########4#########5#########6#########7#########8

#for (i in 1:numSamples) {

(id <- wigFiles[1,1])

## create output directories for each sample ##
dir.create(paste0(outDir, "/", id, "/"), recursive = TRUE)
### LOAD TUMOUR AND NORMAL FILES ###
message("Loading tumour file:", wigFiles[1,1])
tumour_reads <- wigToGRanges(wigFiles[1,2])

(binSize <- as.data.frame(tumour_reads[1,])$width)

message("Reading GC and mappability files")
  if (is.null(gcWig) || gcWig == "None" || gcWig == "NULL"){
      stop("GC wig file is required")
  }

gc <- wigToGRanges(gcWig)

if (is.null(mapWig) || mapWig == "None" || mapWig == "NULL"){
  message("No mappability wig file input, excluding from correction")
  map <- NULL
} else {
  map <- wigToGRanges(mapWig)
  }

message("Correcting Tumour")

counts <- loadReadCountsFromWig(tumour_reads, chrs = chrs, gc = gc, map = map,
                                centromere = centromere, flankLength = flankLength,
                                targetedSequences = targetedSequences, chrXMedianForMale = chrXMedianForMale,
                                genomeStyle = NULL, fracReadsInChrYForMale = fracReadsInChrYForMale,
                                chrNormalize = chrNormalize, mapScoreThres = minMapScore)

counts <- loadReadCountsFromWig(tumour_reads, chrs = chrs, gc = gc, genomeStyle = "UCSC", applyCorrection = F)

counts

#########1#########2#########3#########4#########5#########6#########7#########8
counts = tumour_reads
#loadReadCountsFromWig <- function(counts, chrs = c(1:22, "X", "Y"), gc = NULL, map = NULL, centromere = NULL, flankLength = 100000, targetedSequences = NULL, genomeStyle = "NCBI", applyCorrection = TRUE, mapScoreThres = 0.9, chrNormalize = c(1:22, "X", "Y"), fracReadsInChrYForMale = 0.002, chrXMedianForMale = -0.5, useChrY = TRUE){

require(HMMcopy)
require(GenomeInfoDb)
seqlevelsStyle(counts) <- genomeStyle
counts.raw <- counts
counts <- keepChr(counts, chrs)

if (!is.null(gc)){
  seqlevelsStyle(gc) <- genomeStyle
  counts$gc <- keepChr(gc, chrs)$value
}

if (!is.null(map)){
  seqlevelsStyle(map) <- genomeStyle
  counts$map <- keepChr(map, chrs)$value
}

colnames(values(counts))[1] <- c("reads")

# remove centromeres
if (!is.null(centromere)){
  counts <- excludeCentromere(counts, centromere, flankLength = flankLength, genomeStyle=genomeStyle)
}

# keep targeted sequences
if (!is.null(targetedSequences)){
  colnames(targetedSequences)[1:3] <- c("chr", "start", "end")
  targetedSequences.GR <- as(targetedSequences, "GRanges")
  seqlevelsStyle(targetedSequences.GR) <- genomeStyle
  countsExons <- filterByTargetedSequences(counts, targetedSequences.GR)
  counts <- counts[countsExons$ix,]
}

gender <- NULL

if (applyCorrection){
  ## correct read counts ##
  counts <- correctReadCounts(counts, chrNormalize = chrNormalize)
  if (!is.null(map)) {
    ## filter bins by mappability
    counts <- filterByMappabilityScore(counts, map=map, mapScoreThres = mapScoreThres)
  }
  ## get gender ##
  gender <- getGender(counts.raw, counts, gc, map, fracReadsInChrYForMale = fracReadsInChrYForMale,
                      chrXMedianForMale = chrXMedianForMale, useChrY = useChrY,
                      centromere=centromere, flankLength=flankLength, targetedSequences = targetedSequences,
                      genomeStyle = genomeStyle)
}

return(list(counts = counts, gender = gender))
}

#########1#########2#########3#########4#########5#########6#########7#########8

find("keepSeqlevels")

class(tumour_reads)

# Example GRanges object
gr <- GRanges(seqnames = c("chr1", "chr2"),
              ranges = IRanges(start = c(100, 200), end = c(150, 250)),
              strand = c("+", "-"))

tumour_reads

(seqlevelsStyle(tumour_reads) <- "NCBI")

# Extract the Seqinfo metadata
test=keepSeqlevels(tumour_reads, chrs, pruning.mode="coarse")

(seqlevelsStyle(tumour_reads) <- "UCSC")

test=keepSeqlevels(tumour_reads, chrs, pruning.mode="coarse")

test

sortSeqlevels(tumour_reads)


keepChr <- function(tumour_reads, chrs = c(1:22,"X","Y")){
	tumour_reads <- keepSeqlevels(tumour_reads, chrs, pruning.mode="coarse")
	sortSeqlevels(tumour_reads)
	return(sort(tumour_reads))
}

test = keepChr(tumour_reads, chrs)

test

counts = keepChr(counts, chrs)

test = keepChr(gc, chrs)

test
loadReadCountsFromWig <- function(counts, chrs = c(1:22, "X", "Y"), gc = NULL, map = NULL, centromere = NULL, flankLength = 100000, targetedSequences = NULL, genomeStyle = "NCBI", applyCorrection = TRUE, mapScoreThres = 0.9, chrNormalize = c(1:22, "X", "Y"), fracReadsInChrYForMale = 0.002, chrXMedianForMale = -0.5, useChrY = TRUE){
	require(HMMcopy)
	require(GenomeInfoDb)
	counts.raw <- counts
	counts <- keepChr(counts, chrs)

	if (!is.null(gc)){
		counts$gc <- keepChr(gc, chrs)$value
	}
	if (!is.null(map)){
		counts$map <- keepChr(map, chrs)$value
	}
	colnames(values(counts))[1] <- c("reads")


	# remove centromeres
	if (!is.null(centromere)){
		counts <- excludeCentromere(counts, centromere, flankLength = flankLength, genomeStyle=genomeStyle)
	}
	# keep targeted sequences
	if (!is.null(targetedSequences)){
		colnames(targetedSequences)[1:3] <- c("chr", "start", "end")
		targetedSequences.GR <- as(targetedSequences, "GRanges")
		countsExons <- filterByTargetedSequences(counts, targetedSequences.GR)
		counts <- counts[countsExons$ix,]
	}
	gender <- NULL
	if (applyCorrection){
		## correct read counts ##

		counts <- correctReadCounts(counts, chrNormalize = chrNormalize)
		if (!is.null(map)) {
		  ## filter bins by mappability
		  counts <- filterByMappabilityScore(counts, map=map, mapScoreThres = mapScoreThres)
		}
   }
  return(list(counts = counts, gender = gender))
}

filterByMappabilityScore <- function(counts, map, mapScoreThres = 0.9){
	message("Filtering low uniqueness regions with mappability score < ", mapScoreThres)
	counts <- counts[counts$map >= mapScoreThres, ]
	return(counts)
}



, gc = NULL, map = NULL, centromere = NULL, flankLength = 100000, targetedSequences = NULL, genomeStyle = "NCBI", applyCorrection = TRUE, mapScoreThres = 0.9, chrNormalize = c(1:22, "X", "Y"), fracReadsInChrYForMale = 0.002, chrXMedianForMale = -0.5, useChrY = TRUE){



tumour_reads

 counts <- loadReadCountsFromWig(tumour_reads, chrs = chrs, gc = gc, map = map,
                                       centromere = centromere, flankLength = flankLength,
                                       targetedSequences = targetedSequences, chrXMedianForMale = chrXMedianForMale,
                                       genomeStyle = NULL, fracReadsInChrYForMale = fracReadsInChrYForMale,
                                       chrNormalize = chrNormalize, mapScoreThres = minMapScore)
  tumour_copy[[id]] <- counts$counts #as(counts$counts, "GRanges")
  gender <- counts$gender
  ## load in normal file if provided
  if (!is.null(normal_file) && normal_file != "None" && normal_file != "NULL"){
	message("Loading normal file:", normal_file)
	normal_reads <- wigToGRanges(normal_file)
	message("Correcting Normal")
	counts <- loadReadCountsFromWig(normal_reads, chrs=chrs, gc=gc, map=map,
			centromere=centromere, flankLength = flankLength, targetedSequences=targetedSequences,
			genomeStyle = NULL, chrNormalize = chrNormalize, mapScoreThres = minMapScore)
	normal_copy <- counts$counts #as(counts$counts, "GRanges")
	gender.normal <- counts$gender
  }else{
	normal_copy <- NULL
  }
#+end_src

- Working intro code
  #+begin_src R
# file:   ichorCNA.R
# authors: Gavin Ha, Ph.D.
#          Fred Hutch
# contact: <gha@fredhutch.org>
#
#         Justin Rhoades
#          Broad Institute
# contact: <rhoades@broadinstitute.org>

# ichorCNA: https://github.com/broadinstitute/ichorCNA
# date:   July 24, 2019
# description: Hidden Markov model (HMM) to analyze Ultra-low pass whole genome sequencing (ULP-WGS) data.
# This script is the main script to run the HMM.

library(optparse)

option_list <- list(
  make_option(c("--WIG"), type = "character", help = "Path to tumor WIG file. Required."),
  make_option(c("--NORMWIG"), type = "character", default=NULL, help = "Path to normal WIG file. Default: [%default]"),
  make_option(c("--gcWig"), type = "character", help = "Path to GC-content WIG file; Required"),
  make_option(c("--mapWig"), type = "character", default=NULL, help = "Path to mappability score WIG file. Default: [%default]"),
  make_option(c("--normalPanel"), type="character", default=NULL, help="Median corrected depth from panel of normals. Default: [%default]"),
  make_option(c("--exons.bed"), type = "character", default=NULL, help = "Path to bed file containing exon regions. Default: [%default]"),
  make_option(c("--id"), type = "character", default="test", help = "Patient ID. Default: [%default]"),
  make_option(c("--centromere"), type="character", default=NULL, help = "File containing Centromere locations; if not provided then will use hg19 version from ichorCNA package. Default: [%default]"),
  make_option(c("--minMapScore"), type = "numeric", default=0.9, help="Include bins with a minimum mappability score of this value. Default: [%default]."),
  make_option(c("--rmCentromereFlankLength"), type="numeric", default=1e5, help="Length of region flanking centromere to remove. Default: [%default]"),
  make_option(c("--normal"), type="character", default="0.5", help = "Initial normal contamination; can be more than one value if additional normal initializations are desired. Default: [%default]"),
  make_option(c("--scStates"), type="character", default="NULL", help = "Subclonal states to consider. Default: [%default]"),
  make_option(c("--coverage"), type="numeric", default=NULL, help = "PICARD sequencing coverage. Default: [%default]"),
  make_option(c("--lambda"), type="character", default="NULL", help="Initial Student's t precision; must contain 4 values (e.g. c(1500,1500,1500,1500)); if not provided then will automatically use based on variance of data. Default: [%default]"),
  make_option(c("--lambdaScaleHyperParam"), type="numeric", default=3, help="Hyperparameter (scale) for Gamma prior on Student's-t precision. Default: [%default]"),
  #	make_option(c("--kappa"), type="character", default=50, help="Initial state distribution"),
  make_option(c("--ploidy"), type="character", default="2", help = "Initial tumour ploidy; can be more than one value if additional ploidy initializations are desired. Default: [%default]"),
  make_option(c("--maxCN"), type="numeric", default=7, help = "Total clonal CN states. Default: [%default]"),
  make_option(c("--estimateNormal"), type="logical", default=TRUE, help = "Estimate normal. Default: [%default]"),
  make_option(c("--estimateScPrevalence"), type="logical", default=TRUE, help = "Estimate subclonal prevalence. Default: [%default]"),
  make_option(c("--estimatePloidy"), type="logical", default=TRUE, help = "Estimate tumour ploidy. Default: [%default]"),
  make_option(c("--maxFracCNASubclone"), type="numeric", default=0.7, help="Exclude solutions with fraction of subclonal events greater than this value. Default: [%default]"),
  make_option(c("--maxFracGenomeSubclone"), type="numeric", default=0.5, help="Exclude solutions with subclonal genome fraction greater than this value. Default: [%default]"),
  make_option(c("--minSegmentBins"), type="numeric", default=50, help="Minimum number of bins for largest segment threshold required to estimate tumor fraction; if below this threshold, then will be assigned zero tumor fraction."),
  make_option(c("--altFracThreshold"), type="numeric", default=0.05, help="Minimum proportion of bins altered required to estimate tumor fraction; if below this threshold, then will be assigned zero tumor fraction. Default: [%default]"),
  make_option(c("--chrNormalize"), type="character", default="c(1:22)", help = "Specify chromosomes to normalize GC/mappability biases. Default: [%default]"),
  make_option(c("--chrTrain"), type="character", default="c(1:22)", help = "Specify chromosomes to estimate params. Default: [%default]"),
  make_option(c("--chrs"), type="character", default="c(1:22,\"X\")", help = "Specify chromosomes to analyze. Default: [%default]"),
  make_option(c("--genomeBuild"), type="character", default="hg19", help="Geome build. Default: [%default]"),
  make_option(c("--genomeStyle"), type = "character", default = "NCBI", help = "NCBI or UCSC chromosome naming convention; use UCSC if desired output is to have \"chr\" string. [Default: %default]"),
  make_option(c("--normalizeMaleX"), type="logical", default=TRUE, help = "If male, then normalize chrX by median. Default: [%default]"),
  make_option(c("--minTumFracToCorrect"), type="numeric", default=0.1, help = "Tumor-fraction correction of bin and segment-level CNA if sample has minimum estimated tumor fraction. [Default: %default]"),
  make_option(c("--fracReadsInChrYForMale"), type="numeric", default=0.001, help = "Threshold for fraction of reads in chrY to assign as male. Default: [%default]"),
  make_option(c("--includeHOMD"), type="logical", default=FALSE, help="If FALSE, then exclude HOMD state. Useful when using large bins (e.g. 1Mb). Default: [%default]"),
  make_option(c("--txnE"), type="numeric", default=0.9999999, help = "Self-transition probability. Increase to decrease number of segments. Default: [%default]"),
  make_option(c("--txnStrength"), type="numeric", default=1e7, help = "Transition pseudo-counts. Exponent should be the same as the number of decimal places of --txnE. Default: [%default]"),
  make_option(c("--plotFileType"), type="character", default="pdf", help = "File format for output plots. Default: [%default]"),
	make_option(c("--plotYLim"), type="character", default="c(-2,2)", help = "ylim to use for chromosome plots. Default: [%default]"),
  make_option(c("--outDir"), type="character", default="./", help = "Output Directory. Default: [%default]"),
  make_option(c("--libdir"), type = "character", default=NULL, help = "Script library path. Usually exclude this argument unless custom modifications have been made to the ichorCNA R package code and the user would like to source those R files. Default: [%default]")
)

parseobj <- OptionParser(option_list=option_list)
opt <- parse_args(parseobj)

print(opt)

options(scipen=0, stringsAsFactors=F)

library(HMMcopy)
library(GenomicRanges)
library(GenomeInfoDb)
options(stringsAsFactors=FALSE)
options(bitmapType='cairo')

(patientID <- opt$id)

(tumour_file <- opt$WIG)

tumour_file = "/mnt/data/projects/cfdna-cna/lib003_frag90_150.wig"

(normal_file <- opt$NORMWIG)

(gcWig <- opt$gcWig)
gcWig = "/home/jeszyman/repos/ichorCNA/inst/extdata/gc_hg38_1000kb.wig"

(mapWig <- opt$mapWig)
mapWig = "/home/jeszyman/repos/ichorCNA/inst/extdata/map_hg38_1000kb.wig"

(normal_panel <- opt$normalPanel)

(normal_panel = "/home/jeszyman/repos/ichorCNA/inst/extdata/HD_ULP_PoN_hg38_1Mb_median_normAutosome_median.rds")

(exons.bed <- opt$exons.bed)  # "0" if none specified)

(centromere <- opt$centromere)
centromere = "/home/jeszyman/repos/ichorCNA/inst/extdata/GRCh38.GCA_000001405.2_centromere_acen.txt"

(minMapScore <- opt$minMapScore)

(flankLength <- opt$rmCentromereFlankLength)

(normal <- eval(parse(text = opt$normal)))

(scStates <- eval(parse(text = opt$scStates)))

(lambda <- eval(parse(text = opt$lambda)))

(lambdaScaleHyperParam <- opt$lambdaScaleHyperParam)

(estimateNormal <- opt$estimateNormal)

(estimatePloidy <- opt$estimatePloidy)

(estimateScPrevalence <- opt$estimateScPrevalence)

(maxFracCNASubclone <- opt$maxFracCNASubclone)

(maxFracGenomeSubclone <- opt$maxFracGenomeSubclone)

(minSegmentBins <- opt$minSegmentBins)

(altFracThreshold <- opt$altFracThreshold)

(ploidy <- eval(parse(text = opt$ploidy)))

(coverage <- opt$coverage)

(maxCN <- opt$maxCN)

(txnE <- opt$txnE)

(txnStrength <- opt$txnStrength)

(normalizeMaleX <- as.logical(opt$normalizeMaleX))

(includeHOMD <- as.logical(opt$includeHOMD))

(minTumFracToCorrect <- opt$minTumFracToCorrect)

(fracReadsInChrYForMale <- opt$fracReadsInChrYForMale)

(chrXMedianForMale <- -0.1)

(outDir <- opt$outDir)
outDir = "/tmp/ichor2"

(libdir <- opt$libdir)
libdir = "/home/jeszyman/repos/ichorCNA"

(plotFileType <- opt$plotFileType)

(plotYLim <- eval(parse(text=opt$plotYLim)))

(gender <- NULL)

(outImage <- paste0(outDir,"/", patientID,".RData"))

(genomeBuild <- opt$genomeBuild)
genomeBuild = "hg38"

(genomeStyle <- opt$genomeStyle)
genomeStyle = "UCSC"

(chrs <- as.character(eval(parse(text = opt$chrs))))

(chrTrain <- as.character(eval(parse(text=opt$chrTrain))))

(chrNormalize <- as.character(eval(parse(text=opt$chrNormalize))))

(seqlevelsStyle(chrs) <- genomeStyle)

(seqlevelsStyle(chrNormalize) <- genomeStyle)

(seqlevelsStyle(chrTrain) <- genomeStyle)

## load ichorCNA library or source R scripts
if (!is.null(libdir) && libdir != "None"){
	source(paste0(libdir,"/R/utils.R"))
	source(paste0(libdir,"/R/segmentation.R"))
	source(paste0(libdir,"/R/EM.R"))
	source(paste0(libdir,"/R/output.R"))
	source(paste0(libdir,"/R/plotting.R"))
} else {
    library(ichorCNA)
}

#########1#########2#########3#########4#########5#########6#########7#########8
getSeqInfo <- function(genomeBuild = "hg19", genomeStyle = "NCBI"){
	bsg <- paste0("BSgenome.Hsapiens.UCSC.", genomeBuild)
	if (!require(bsg, character.only=TRUE, quietly=TRUE, warn.conflicts=FALSE)) {
		seqinfo <- Seqinfo(genome=genomeBuild)
	} else {
		seqinfo <- seqinfo(get(bsg))
	}
	seqlevelsStyle(seqinfo) <- genomeStyle
	seqinfo <- keepSeqlevels(seqinfo, value = chrs)
	#seqinfo <- cbind(seqnames = seqnames(seqinfo), as.data.frame(seqinfo))
	return(seqinfo)
}
#########1#########2#########3#########4#########5#########6#########7#########8


## load seqinfo
seqinfo <- getSeqInfo(genomeBuild, genomeStyle)

seqinfo

if (substr(tumour_file,nchar(tumour_file)-2,nchar(tumour_file)) == "wig") {
  wigFiles <- data.frame(cbind(patientID, tumour_file))
} else {
  wigFiles <- read.delim(tumour_file, header=F, as.is=T)
}

wigFiles

## FILTER BY EXONS IF PROVIDED ##
## add gc and map to GRanges object ##
if (is.null(exons.bed) || exons.bed == "None" || exons.bed == "NULL"){
  targetedSequences <- NULL
}else{
  targetedSequences <- read.delim(exons.bed, header=T, sep="\t")
}

targetedSequences

## load PoN
if (is.null(normal_panel) || normal_panel == "None" || normal_panel == "NULL"){
	normal_panel <- NULL
}

normal_panel

if (is.null(centromere) || centromere == "None" || centromere == "NULL"){ # no centromere file provided
	centromere <- system.file("extdata", "GRCh37.p13_centromere_UCSC-gapTable.txt",
			package = "ichorCNA")
}

centromere

centromere <- read.delim(centromere,header=T,stringsAsFactors=F,sep="\t")

# Save all global env objects in an .RData
save.image(outImage)

## LOAD IN WIG FILES ##
(numSamples <- nrow(wigFiles))

tumour_copy <- list()
for (i in 1:numSamples) {
  id <- wigFiles[i,1]
  ## create output directories for each sample ##
  dir.create(paste0(outDir, "/", id, "/"), recursive = TRUE)
  ### LOAD TUMOUR AND NORMAL FILES ###
  message("Loading tumour file:", wigFiles[i,1])
  tumour_reads <- wigToGRanges(wigFiles[i,2])

  ## LOAD GC/MAP WIG FILES ###
  # find the bin size and load corresponding wig files #
  binSize <- as.data.frame(tumour_reads[1,])$width
  message("Reading GC and mappability files")
  if (is.null(gcWig) || gcWig == "None" || gcWig == "NULL"){
      stop("GC wig file is required")
  }
  gc <- wigToGRanges(gcWig)
  if (is.null(mapWig) || mapWig == "None" || mapWig == "NULL"){
      message("No mappability wig file input, excluding from correction")
      map <- NULL
  } else {
      map <- wigToGRanges(mapWig)
  }
  message("Correcting Tumour")

  counts <- loadReadCountsFromWig(tumour_reads, chrs = chrs, gc = gc, map = map,
                                       centromere = centromere, flankLength = flankLength,
                                       targetedSequences = targetedSequences, chrXMedianForMale = chrXMedianForMale,
                                       genomeStyle = genomeStyle, fracReadsInChrYForMale = fracReadsInChrYForMale,
                                       chrNormalize = chrNormalize, mapScoreThres = minMapScore)
  tumour_copy[[id]] <- counts$counts #as(counts$counts, "GRanges")
  gender <- counts$gender
  ## load in normal file if provided
  if (!is.null(normal_file) && normal_file != "None" && normal_file != "NULL"){
	message("Loading normal file:", normal_file)
	normal_reads <- wigToGRanges(normal_file)
	message("Correcting Normal")
	counts <- loadReadCountsFromWig(normal_reads, chrs=chrs, gc=gc, map=map,
			centromere=centromere, flankLength = flankLength, targetedSequences=targetedSequences,
			genomeStyle = genomeStyle, chrNormalize = chrNormalize, mapScoreThres = minMapScore)
	normal_copy <- counts$counts #as(counts$counts, "GRanges")
	gender.normal <- counts$gender
  }else{
	normal_copy <- NULL
  }

  ### DETERMINE GENDER ###
  ## if normal file not given, use chrY, else use chrX
  message("Determining gender...", appendLF = FALSE)
  gender.mismatch <- FALSE
  if (!is.null(normal_copy)){
	if (gender$gender != gender.normal$gender){ #use tumour # use normal if given
	# check if normal is same gender as tumour
	  gender.mismatch <- TRUE
	}
  }
  message("Gender ", gender$gender)

  ## NORMALIZE GENOME-WIDE BY MATCHED NORMAL OR NORMAL PANEL (MEDIAN) ##
  tumour_copy[[id]] <- normalizeByPanelOrMatchedNormal(tumour_copy[[id]], chrs = chrs,
      normal_panel = normal_panel, normal_copy = normal_copy,
      gender = gender$gender, normalizeMaleX = normalizeMaleX)

	### OUTPUT FILE ###
	### PUTTING TOGETHER THE COLUMNS IN THE OUTPUT ###
	outMat <- as.data.frame(tumour_copy[[id]])
	#outMat <- outMat[,c(1,2,3,12)]
	outMat <- outMat[,c("seqnames","start","end","copy")]
	colnames(outMat) <- c("chr","start","end","log2_TNratio_corrected")
	outFile <- paste0(outDir,"/",id,".correctedDepth.txt")
	message(paste("Outputting to:", outFile))
	write.table(outMat, file=outFile, row.names=F, col.names=T, quote=F, sep="\t")

} ## end of for each sample

#########1#########2#########3#########4#########5#########6#########7#########8

id
outDir

# Helper function to create output directory
create_output_dir <- function(outDir, id) {
  dir_path <- file.path(outDir, id)
  if (!dir.exists(dir_path)) {
    dir.create(dir_path, recursive = TRUE)
  }
  return(dir_path)
}

create_output_dir(outDir, id)

wigFiles[1,2]

#########1#########2#########3#########4#########5#########6#########7#########8

wigToGRanges <- function(wigfile, verbose = TRUE){
  if (verbose) { message(paste("Slurping:", wigfile)) }
  input <- readLines(wigfile, warn = FALSE)
  breaks <- c(grep("fixedStep", input), length(input) + 1)
  temp <- NULL
  span <- NULL
  for (i in 1:(length(breaks) - 1)) {
    data_range <- (breaks[i] + 1):(breaks[i + 1] - 1)
    track_info <- input[breaks[i]]
    if (verbose) { message(paste("Parsing:", track_info)) }
    tokens <- strsplit(
      sub("fixedStep chrom=(\\S+) start=(\\d+) step=(\\d+) span=(\\d+)",
          "\\1 \\2 \\3 \\4", track_info, perl = TRUE), " ")[[1]]
    span <- as.integer(tokens[4])
    chr <- rep.int(tokens[1], length(data_range))
    pos <- seq(from = as.integer(tokens[2]), by = as.integer(tokens[3]),
               length.out = length(data_range))
    val <- as.numeric(input[data_range])
    temp <- c(temp, list(data.frame(chr, pos, val)))
  }
  if (verbose) { message("Sorting by decreasing chromosome size") }
  lengths <- as.integer(lapply(temp, nrow))
  temp <- temp[order(lengths, decreasing = TRUE)]
  temp = do.call("rbind", temp)
  output <- GenomicRanges::GRanges(ranges = IRanges(start = temp$pos, width = span),
                       seqnames = temp$chr, value = temp$val)
  return(output)
}

wigToGRanges <- function(wigfile, verbose = TRUE){
  # Optionally announce the file being read
  if (verbose) { message(paste("Slurping:", wigfile)) }
  # Read all lines from the wig file into a character vector
  input <- readLines(wigfile, warn = FALSE)

  # Find indices of header lines starting with "fixedStep"
  # Append an extra index (end of file + 1) to delimit the last block
  breaks <- c(grep("fixedStep", input), length(input) + 1)

  temp <- NULL  # Container for data frames from each block
  span <- NULL  # Will hold the span value for the ranges

  # Loop over each header block in the wig file
  for (i in 1:(length(breaks) - 1)) {
    # Define the range of lines that hold numeric data for this block
    data_range <- (breaks[i] + 1):(breaks[i + 1] - 1)
    # Extract the header line containing track information
    track_info <- input[breaks[i]]
    if (verbose) { message(paste("Parsing:", track_info)) }

    # Extract tokens: chromosome, start, step, and span from the header
    # The regular expression captures these values in order
    tokens <- strsplit(
      sub("fixedStep chrom=(\\S+) start=(\\d+) step=(\\d+) span=(\\d+)",
          "\\1 \\2 \\3 \\4", track_info, perl = TRUE), " ")[[1]]

    # Convert the extracted span to an integer
    span <- as.integer(tokens[4])
    # Create a vector of chromosome names, repeated for each data point
    chr <- rep.int(tokens[1], length(data_range))
    # Generate a sequence of positions starting at 'start' and incremented by 'step'
    pos <- seq(from = as.integer(tokens[2]), by = as.integer(tokens[3]),
               length.out = length(data_range))
    # Convert the data lines to numeric values
    val <- as.numeric(input[data_range])

    # Store the parsed block as a data frame
    temp <- c(temp, list(data.frame(chr, pos, val)))
  }

  if (verbose) { message("Sorting by decreasing chromosome size") }
  # Get the number of rows (data points) in each block
  lengths <- as.integer(lapply(temp, nrow))
  # Sort the list of data frames in decreasing order by their size
  temp <- temp[order(lengths, decreasing = TRUE)]
  # Combine all the blocks into one data frame
  temp <- do.call("rbind", temp)

  # Create a GRanges object from the combined data
  # Each range starts at 'pos' with fixed width 'span'
  # 'seqnames' are given by 'chr' and the associated value is stored in 'value'
  output <- GenomicRanges::GRanges(ranges = IRanges(start = temp$pos, width = span),
                                   seqnames = temp$chr, value = temp$val)
  return(output)
}

#########1#########2#########3#########4#########5#########6#########7#########8

reads = wigToGRanges(tumour_file)


#########1#########2#########3#########4#########5#########6#########7#########8
loadReadCountsFromWig <- function(counts,
                                  chrs = c(1:22, "X", "Y"),
                                  gc = NULL,
                                  map = NULL,
                                  centromere = NULL,
                                  flankLength = 100000,
                                  targetedSequences = NULL,
                                  genomeStyle = "NCBI",
                                  applyCorrection = TRUE,
                                  mapScoreThres = 0.9,
                                  chrNormalize = c(1:22, "X", "Y"),
                                  fracReadsInChrYForMale = 0.002,
                                  chrXMedianForMale = -0.5,
                                  useChrY = TRUE){
  # Load required packages for genomic data processing
  require(HMMcopy)
  require(GenomeInfoDb)

  # Set the naming style of chromosomes (e.g., "NCBI" or "UCSC")
  seqlevelsStyle(counts) <- genomeStyle

  # Save the original counts for later use (e.g., in gender inference)
  counts.raw <- counts

  # Filter counts to include only specified chromosomes
  counts <- keepChr(counts, chrs)

  # If GC content is provided, set its naming style and attach the values to counts
  if (!is.null(gc)){
    seqlevelsStyle(gc) <- genomeStyle
    counts$gc <- keepChr(gc, chrs)$value
  }

  # If mappability data is provided, set its naming style and attach the values to counts
  if (!is.null(map)){
    seqlevelsStyle(map) <- genomeStyle
    counts$map <- keepChr(map, chrs)$value
  }

  # Rename the first column of the counts values to "reads"
  colnames(values(counts))[1] <- "reads"

  # Remove centromere regions (and flanking regions) if centromere data is provided
  if (!is.null(centromere)){
    counts <- excludeCentromere(counts, centromere, flankLength = flankLength, genomeStyle = genomeStyle)
  }

  # If targeted sequences are provided, filter counts to only include these regions
  if (!is.null(targetedSequences)){
    # Ensure the targeted sequences have proper column names
    colnames(targetedSequences)[1:3] <- c("chr", "start", "end")
    # Convert to GRanges object and standardize chromosome naming
    targetedSequences.GR <- as(targetedSequences, "GRanges")
    seqlevelsStyle(targetedSequences.GR) <- genomeStyle
    # Identify and keep only counts overlapping the targeted sequences
    countsExons <- filterByTargetedSequences(counts, targetedSequences.GR)
    counts <- counts[countsExons$ix,]
  }

  # Initialize gender as NULL; will be inferred later if corrections are applied
  gender <- NULL

  # If corrections should be applied:
  if (applyCorrection){
    # Normalize read counts across specified chromosomes to reduce biases
    counts <- correctReadCounts(counts, chrNormalize = chrNormalize)

    # Filter bins with low mappability if mappability data is provided
    if (!is.null(map)) {
      counts <- filterByMappabilityScore(counts, map = map, mapScoreThres = mapScoreThres)
    }

    # Infer sample gender based on read distributions on sex chromosomes (chrX/chrY)
    gender <- getGender(counts.raw, counts, gc, map,
                          fracReadsInChrYForMale = fracReadsInChrYForMale,
                          chrXMedianForMale = chrXMedianForMale,
                          useChrY = useChrY,
                          centromere = centromere,
                          flankLength = flankLength,
                          targetedSequences = targetedSequences,
                          genomeStyle = genomeStyle)
  }

  # Return a list with the processed counts and the inferred gender
  return(list(counts = counts, gender = gender))
}

#########1#########2#########3#########4#########5#########6#########7#########8

counts <- loadReadCountsFromWig(reads, chrs = chrs, gc = gc, map = map,
                                centromere = centromere, flankLength = flankLength,
                                targetedSequences = targetedSequences, chrXMedianForMale = chrXMedianForMale,
                                genomeStyle = genomeStyle, fracReadsInChrYForMale = fracReadsInChrYForMale,
                                chrNormalize = chrNormalize, mapScoreThres = minMapScore)


counts
tumour_copy = counts$counts

(gender = counts$gender)

gender

#########1#########2#########3#########4#########5#########6#########7#########8

## load in normal file if provided
if (!is.null(normal_file) && normal_file != "None" && normal_file != "NULL"){
  message("Loading normal file:", normal_file)
  normal_reads <- wigToGRanges(normal_file)
  message("Correcting Normal")
  counts <- loadReadCountsFromWig(normal_reads, chrs=chrs, gc=gc, map=map,
                                  centromere=centromere, flankLength = flankLength, targetedSequences=targetedSequences,
                                  genomeStyle = genomeStyle, chrNormalize = chrNormalize, mapScoreThres = minMapScore)
  normal_copy <- counts$counts #as(counts$counts, "GRanges")
  gender.normal <- counts$gender
}else{
  normal_copy <- NULL
}

#########1#########2#########3#########4#########5#########6#########7#########8

### DETERMINE GENDER ###
## if normal file not given, use chrY, else use chrX
message("Determining gender...", appendLF = FALSE)
gender.mismatch <- FALSE
if (!is.null(normal_copy)){
  if (gender$gender != gender.normal$gender){ #use tumour # use normal if given
    # check if normal is same gender as tumour
    gender.mismatch <- TRUE
  }
}
message("Gender ", gender$gender)

#########1#########2#########3#########4#########5#########6#########7#########8

normalizeByPanelOrMatchedNormal <- function(tumour_copy, chrs = c(1:22, "X", "Y"),
      normal_panel = NULL, normal_copy = NULL, gender = "female", normalizeMaleX = FALSE){
    genomeStyle <- seqlevelsStyle(tumour_copy)
    seqlevelsStyle(chrs) <- genomeStyle
 	### COMPUTE LOG RATIO FROM MATCHED NORMAL OR PANEL AND HANDLE CHRX ###
	## NO PANEL
	# matched normal but NO panel, then just normalize by matched normal (WES)
	## WHY DO WE NOT NORMALIZE BY NORMAL WITH PANEL? ##
	chrXInd <- grep("X", as.character(seqnames(tumour_copy)))
	chrXMedian <- median(tumour_copy[chrXInd, ]$copy, na.rm = TRUE)
	if (!is.null(normal_copy) && is.null(normal_panel)){
			message("Normalizing Tumour by Normal")
			tumour_copy$copy <- tumour_copy$copy - normal_copy$copy
			rm(normal_copy)
	}
	# matched normal and panel and male, then compute normalized chrX median (WES)
	if (!is.null(normal_copy) && !is.null(normal_panel) && gender=="male"){
			message("Normalizing by matched normal for ChrX")
			chrX.MNnorm <- tumour_copy$copy[chrXInd] - normal_copy$copy[chrXInd]
			chrXMedian.MNnorm <- median(chrX.MNnorm, na.rm = TRUE)
	}
	# if male, then just normalize chrX to median (ULP and WES)
	if (is.null(normal_copy) && gender=="male" && !gender.mismatch && normalizeMaleX){
			tumour_copy$copy[chrXInd] <- tumour_copy$copy[chrXInd] - chrXMedian
	}
	# PANEL, then normalize by panel instead of matched normal (ULP and WES)
	if (!is.null(normal_panel)){
		## load in IRanges object, then convert to GRanges
		panel <- readRDS(normal_panel)
		seqlevelsStyle(panel) <- genomeStyle
		panel <- keepChr(panel, chr = chrs)
        # intersect bins in sample and panel
        hits <- findOverlaps(tumour_copy, panel, type="equal")
        tumour_copy <- tumour_copy[queryHits(hits),]
        panel <- panel[subjectHits(hits),]
        # subtract out panel median
		tumour_copy$copy <- tumour_copy$copy - panel$Median
		# if male, then shift chrX by +chrXMedian.MNnorm
		if (gender == "male" && exists("chrXMedian.MNnorm")){
			tumour_copy$copy[chrXInd] <- tumour_copy$copy[chrXInd] + chrXMedian.MNnorm
		}
	}
	return(tumour_copy)
}


tumour_copy_norm = normalizeByPanelOrMatchedNormal(tumour_copy, chrs = chrs,
                                                     normal_panel = normal_panel, normal_copy = normal_copy,
                                                     gender = gender$gender, normalizeMaleX = normalizeMaleX)



chrInd <- as.character(seqnames(tumour_copy)) %in% chrTrain
chrInd

## get positions that are valid
valid <- tumour_copy$valid
if (length(tumour_copy) >= 2) {
  for (i in 2:length(tumour_copy)){
    valid <- valid & tumour_copy$valid
  }
}

save.image(outImage)


#+end_src

#+begin_src R
#HMMsegment <- function(x, validInd = NULL, dataType = "copy", param = NULL,
#    chrTrain = c(1:22), maxiter = 50, estimateNormal = TRUE, estimatePloidy = TRUE,
#    estimatePrecision = TRUE, estimateSubclone = TRUE, estimateTransition = TRUE,
#    estimateInitDist = TRUE, logTransform = FALSE, verbose = TRUE) {

x = tumour_copy
chr <- as.factor(seqnames(x))
chr

dataType = "copy"
# setup columns for multiple samples #
dataMat <- as.matrix(as.data.frame(lapply(x, function(y) { mcols(x)[, dataType] })))

head(dataMat)

logTransform=FALSE

# normalize by median and log data #
if (logTransform){
  dataMat <- apply(dataMat, 2, function(x){ log(x / median(x, na.rm = TRUE)) })
}else{
  dataMat <- log(2^dataMat)
}

validInd = NULL
chrTrain2 = c(1:22)

## update variable x with loge instead of log2
for (i in 1:length(x)){
  mcols(x)[, dataType] <- dataMat[, i]
}
if (!is.null(chrTrain2)) {
  chrInd2 <- chr %in% chrTrain2
}else{
  chrInd2 <- !logical(length(chr))
}
if (!is.null(validInd2)){
  chrInd2 <- chrInd2 & validInd
}

head(chrInd)

param= NULL

if (is.null(param)){
  param <- getDefaultParameters(dataMat[chrInd])
}

logR <- as.data.frame(lapply(tumour_copy, function(x) { x$copy })) # NEED TO EXCLUDE CHR X #

logR = tumour_copy$copy

#getDefaultParameters <- function(x, maxCN = 5, ct.sc = NULL, ploidy = 2, e = 0.9999999, e.sameState = 10, strength = 10000000, includeHOMD = FALSE){

maxCN = 5
ct.sc = NULL
ploidy = 2
e = 0.9999999
e.sameState = 10
strength = 10000000
includeHOMD = FALSE
includeHOMD=F

if (includeHOMD){
  ct <- 0:maxCN
}else{
  ct <- 1:maxCN
}

param <- list(
		strength = strength, e = e,
		ct = c(ct, ct.sc),
		ct.sc.status = c(rep(FALSE, length(ct)), rep(TRUE, length(ct.sc))),
		phi_0 = 2, alphaPhi = 4, betaPhi = 1.5,
		n_0 = 0.5, alphaN = 2, betaN = 2,
		sp_0 = 0.5, alphaSp = 2, betaSp = 2,
		lambda = as.matrix(rep(100, length(ct)+length(ct.sc)), ncol=1),
		nu = 2.1,
		kappa = rep(75, length(ct)),
		alphaLambda = 5
	)
	K <- length(param$ct)
  ## initialize hyperparameters for precision using observed data ##
	if (!is.null(dim(x))){ # multiple samples (columns)
    param$numberSamples <- ncol(x)
    #betaLambdaVal <- ((apply(x, 2, function(x){ sd(diff(x), na.rm=TRUE) }) / sqrt(length(param$ct))) ^ 2)
    betaLambdaVal <- ((apply(x, 2, sd, na.rm = TRUE) / sqrt(length(param$ct))) ^ 2)
	}else{ # only 1 sample
	  param$numberSamples <- 1
	  betaLambdaVal <- ((sd(x, na.rm = TRUE) / sqrt(length(param$ct))) ^ 2)
	}
	param$betaLambda <- matrix(betaLambdaVal, ncol = param$numberSamples, nrow = length(param$ct), byrow = TRUE)
  param$alphaLambda <- rep(param$alphaLambda, K)

	# increase prior precision for -1, 0, 1 copies at ploidy
	#param$lambda[param$ct %in% c(1,2,3)] <- 1000 # HETD, NEUT, GAIN
	#param$lambda[param$ct == 4] <- 100
	#param$lambda[which.max(param$ct)] <- 50 #highest CN
	#param$lambda[param$ct == 0] <- 1 #HOMD
	S <- param$numberSamples
	logR.var <- 1 / ((apply(x, 2, sd, na.rm = TRUE) / sqrt(length(param$ct))) ^ 2)
	if (!is.null(dim(x))){ # multiple samples (columns)
		param$lambda <- matrix(logR.var, nrow=K, ncol=S, byrow=T, dimnames=list(c(),colnames(x)))
	}else{ # only 1 sample
		#logR.var <- 1 / ((sd(x, na.rm = TRUE) / sqrt(length(param$ct))) ^ 2)
    param$lambda <- matrix(logR.var, length(param$ct))
    param$lambda[param$ct %in% c(2)] <- logR.var
    param$lambda[param$ct %in% c(1,3)] <- logR.var
    param$lambda[param$ct >= 4] <- logR.var / 5
    param$lambda[param$ct == max(param$ct)] <- logR.var / 15
    param$lambda[param$ct.sc.status] <- logR.var / 10
  }
  # define joint copy number states #
  param$jointCNstates <- expand.grid(rep(list(param$ct), S))
  param$jointSCstatus <- expand.grid(rep(list(param$ct.sc.status), S))
  colnames(param$jointCNstates) <- paste0("Sample.", 1:param$numberSamples)
  colnames(param$jointSCstatus) <- paste0("Sample.", 1:param$numberSamples)

	# Initialize transition matrix to the prior
	txn <- getTransitionMatrix(K ^ S, e, strength)
  ## set higher transition probs for same CN states across samples ##
  # joint states where at least "tol" fraction of samples with the same CN state
	#apply(param$jointCNstates, 1, function(x){ sum(duplicated(as.numeric(x))) > 0 })
  cnStateDiff <- apply(param$jointCNstates, 1, function(x){ (abs(max(x) - min(x)))})
  if (e.sameState > 0 & S > 1){
		txn$A[, cnStateDiff == 0] <- txn$A[, cnStateDiff == 0] * e.sameState * K
		txn$A[, cnStateDiff >= 3] <- txn$A[, cnStateDiff >=3]  / e.sameState / K
	}
  for (i in 1:nrow(txn$A)){
    for (j in 1:ncol(txn$A)){
      if (i == j){
        txn$A[i, j] <- e
      }
    }
  }
  txn$A <- normalize(txn$A)
	param$A <- txn$A
	param$dirPrior <- txn$A * strength[1]
  param$A[, param$ct.sc.status] <- param$A[, param$ct.sc.status] / 10
  param$A <- normalize(param$A)
  param$dirPrior[, param$ct.sc.status] <- param$dirPrior[, param$ct.sc.status] / 10

  if (includeHOMD){
    K <- length(param$ct)
    param$A[1, 2:K] <- param$A[1, 2:K] * 1e-5; param$A[2:K, 1] <- param$A[2:K, 1] * 1e-5;
    param$A[1, 1] <- param$A[1, 1] * 1e-5
    param$A <- normalize(param$A); param$dirPrior <- param$A * param$strength
  }

  param$kappa <- rep(75, K ^ S)
  param$kappa[cnStateDiff == 0] <- param$kappa[cnStateDiff == 0] + 125
	param$kappa[cnStateDiff >=3] <- param$kappa[cnStateDiff >=3] - 50
	param$kappa[which(rowSums(param$jointCNstates==2) == S)] <- 800

  return(param)
}

param <- getDefaultParameters(logR[valid & chrInd, , drop=F], maxCN = maxCN, includeHOMD = includeHOMD, ct.sc=scStates, ploidy = floor(p), e=txnE, e.same = 50, strength=txnStrength)


param$phi_0 <- rep(p, numSamples)
param$n_0 <- rep(n, numSamples)


#if (param$n_0 == 0){
	#	param$n_0 <- .Machine$double.eps
	#}
	####### RUN EM ##########
  convergedParams <- runEM(dataMat, chr, chrInd, param, maxiter,
      verbose, estimateNormal = estimateNormal, estimatePloidy = estimatePloidy,
      estimateSubclone = estimateSubclone, estimatePrecision = estimatePrecision,
      estimateTransition = estimateTransition, estimateInitDist = estimateInitDist)
#########1#########2#########3#########4#########5#########6#########7#########8

library(HMMcopy)

rfile <- system.file("extdata", "normal.wig", package = "HMMcopy")
gfile <- system.file("extdata", "gc.wig", package = "HMMcopy")
mfile <- system.file("extdata", "map.wig", package = "HMMcopy")
tfile <- system.file("extdata", "tumour.wig", package = "HMMcopy")

tumour_copy2 <- correctReadcount(wigsToRangedData(tfile, gfile, mfile))

test = HMMcopy::HMMsegment(tumour_copy2)

class(tumour_copy2)

class(tumour_copy)
tumour_copy3 = as.data.table(as.data.frame(tumour_copy))

tumour_copy3$chr=as.character(tumour_copy3$seqnames)

test = HMMcopy::HMMsegment(tumour_copy3)

par(mfrow = c(1, 1))
par(cex.main = 0.5, cex.lab = 0.5, cex.axis = 0.5, mar = c(2, 1.5, 0, 0), mgp = c(1, 0.5, 0))
plotSegments(tumour_copy3, test, pch = ".", ylab = "Tumour Copy Number", xlab = "Chromosome Position")
cols <- stateCols() # 6 default state colours
legend("topleft", c("HOMD", "HETD", "NEUT", "GAIN", "AMPL", "HLAMP"), fill = cols, horiz = TRUE, bty = "n", cex = 0.5)

#########1#########2#########3#########4#########5#########6#########7#########8

getDefaultParameters <- function(x, maxCN = 5, ct.sc = NULL, ploidy = 2, e = 0.9999999, e.sameState = 10, strength = 10000000, includeHOMD = FALSE){
  if (includeHOMD){
    ct <- 0:maxCN
  }else{
    ct <- 1:maxCN
  }
	param <- list(
		strength = strength, e = e,
		ct = c(ct, ct.sc),
		ct.sc.status = c(rep(FALSE, length(ct)), rep(TRUE, length(ct.sc))),
		phi_0 = 2, alphaPhi = 4, betaPhi = 1.5,
		n_0 = 0.5, alphaN = 2, betaN = 2,
		sp_0 = 0.5, alphaSp = 2, betaSp = 2,
		lambda = as.matrix(rep(100, length(ct)+length(ct.sc)), ncol=1),
		nu = 2.1,
		kappa = rep(75, length(ct)),
		alphaLambda = 5
	)
	K <- length(param$ct)
  ## initialize hyperparameters for precision using observed data ##
    ##     if (!is.null(dim(x))){ # multiple samples (columns)
    ## param$numberSamples <- ncol(x)
    ## #betaLambdaVal <- ((apply(x, 2, function(x){ sd(diff(x), na.rm=TRUE) }) / sqrt(length(param$ct))) ^ 2)
    ## betaLambdaVal <- ((apply(x, 2, sd, na.rm = TRUE) / sqrt(length(param$ct))) ^ 2)
    ##     }else{ # only 1 sample
    ##       param$numberSamples <- 1
    ##       betaLambdaVal <- ((sd(x, na.rm = TRUE) / sqrt(length(param$ct))) ^ 2)
  ##     }

  x <- matrix(x, ncol = 1)  # Ensure x is treated as a matrix
  param$numberSamples <- 1
  betaLambdaVal <- ((sd(x, na.rm = TRUE) / sqrt(length(param$ct))) ^ 2)

	param$betaLambda <- matrix(betaLambdaVal, ncol = param$numberSamples, nrow = length(param$ct), byrow = TRUE)
  param$alphaLambda <- rep(param$alphaLambda, K)

	# increase prior precision for -1, 0, 1 copies at ploidy
	#param$lambda[param$ct %in% c(1,2,3)] <- 1000 # HETD, NEUT, GAIN
	#param$lambda[param$ct == 4] <- 100
	#param$lambda[which.max(param$ct)] <- 50 #highest CN
	#param$lambda[param$ct == 0] <- 1 #HOMD
	S <- param$numberSamples
	logR.var <- 1 / ((apply(x, 2, sd, na.rm = TRUE) / sqrt(length(param$ct))) ^ 2)
	if (!is.null(dim(x))){ # multiple samples (columns)
		param$lambda <- matrix(logR.var, nrow=K, ncol=S, byrow=T, dimnames=list(c(),colnames(x)))
	}else{ # only 1 sample
		#logR.var <- 1 / ((sd(x, na.rm = TRUE) / sqrt(length(param$ct))) ^ 2)
    param$lambda <- matrix(logR.var, length(param$ct))
    param$lambda[param$ct %in% c(2)] <- logR.var
    param$lambda[param$ct %in% c(1,3)] <- logR.var
    param$lambda[param$ct >= 4] <- logR.var / 5
    param$lambda[param$ct == max(param$ct)] <- logR.var / 15
    param$lambda[param$ct.sc.status] <- logR.var / 10
  }
  # define joint copy number states #
  param$jointCNstates <- expand.grid(rep(list(param$ct), S))
  param$jointSCstatus <- expand.grid(rep(list(param$ct.sc.status), S))
  colnames(param$jointCNstates) <- paste0("Sample.", 1:param$numberSamples)
  colnames(param$jointSCstatus) <- paste0("Sample.", 1:param$numberSamples)

	# Initialize transition matrix to the prior
	txn <- getTransitionMatrix(K ^ S, e, strength)
  ## set higher transition probs for same CN states across samples ##
  # joint states where at least "tol" fraction of samples with the same CN state
	#apply(param$jointCNstates, 1, function(x){ sum(duplicated(as.numeric(x))) > 0 })
  cnStateDiff <- apply(param$jointCNstates, 1, function(x){ (abs(max(x) - min(x)))})
  if (e.sameState > 0 & S > 1){
		txn$A[, cnStateDiff == 0] <- txn$A[, cnStateDiff == 0] * e.sameState * K
		txn$A[, cnStateDiff >= 3] <- txn$A[, cnStateDiff >=3]  / e.sameState / K
	}
  for (i in 1:nrow(txn$A)){
    for (j in 1:ncol(txn$A)){
      if (i == j){
        txn$A[i, j] <- e
      }
    }
  }
  txn$A <- normalize(txn$A)
	param$A <- txn$A
	param$dirPrior <- txn$A * strength[1]
  param$A[, param$ct.sc.status] <- param$A[, param$ct.sc.status] / 10
  param$A <- normalize(param$A)
  param$dirPrior[, param$ct.sc.status] <- param$dirPrior[, param$ct.sc.status] / 10

  if (includeHOMD){
    K <- length(param$ct)
    param$A[1, 2:K] <- param$A[1, 2:K] * 1e-5; param$A[2:K, 1] <- param$A[2:K, 1] * 1e-5;
    param$A[1, 1] <- param$A[1, 1] * 1e-5
    param$A <- normalize(param$A); param$dirPrior <- param$A * param$strength
  }

  param$kappa <- rep(75, K ^ S)
  param$kappa[cnStateDiff == 0] <- param$kappa[cnStateDiff == 0] + 125
	param$kappa[cnStateDiff >=3] <- param$kappa[cnStateDiff >=3] - 50
	param$kappa[which(rowSums(param$jointCNstates==2) == S)] <- 800

  return(param)
}


test=getDefaultParameters(as.matrix(tumour_copy3))
class(tumour_copy3)

test
#########1#########2#########3#########4#########5#########6#########7#########8

## HMMsegment <- function(x, validInd = NULL, dataType = "copy", param = NULL,
##     chrTrain = c(1:22), maxiter = 50, estimateNormal = TRUE, estimatePloidy = TRUE,
##     estimatePrecision = TRUE, estimateSubclone = TRUE, estimateTransition = TRUE,
##     estimateInitDist = TRUE, logTransform = FALSE, verbose = TRUE) {

tumour_copy
x = tumour_copy


chrTrain = c(1:22)
dataType = "copy"
estimateInitDist = TRUE
estimateNormal = TRUE
estimatePloidy = TRUE
estimatePrecision = TRUE
estimateSubclone = TRUE
estimateTransition = TRUE
logTransform = FALSE
maxiter = 50
param = NULL
validInd = NULL
verbose = TRUE

chr <- as.factor(seqnames(x))

head(x)

  # Extract data as a matrix
dataMat <- matrix(mcols(x)[, dataType], ncol = 1)

# Normalize by median and log data
if (logTransform) {
  dataMat <- log(dataMat / median(dataMat, na.rm = TRUE))
} else {
  dataMat <- log(2^dataMat)
}

# Update x with log-transformed values
mcols(x)[, dataType] <- dataMat

if (!is.null(chrTrain)) {
  chrInd <- chr %in% chrTrain
} else {
  chrInd <- rep(TRUE, length(chr))
}
if (!is.null(validInd)) {
  chrInd <- chrInd & validInd
}

if (is.null(param)) {
  param <- getDefaultParameters(dataMat[chrInd])
}

head(dataMat)
dataMat
chr
chrTrain
head(chrInd)

chrTrainLogical <- as.character(seqnames(x)) %in% paste0("chr", chrTrain)

head(chrTrainLogical)
length(chrTrainLogical)

param

runEM(dataMat, chr, chrTrainLogical, param = NULL)

if (is.null(param)){
		param <- getDefaultParameters(dataMat[chrInd])
}

param

# Run EM algorithm
convergedParams <- runEM(dataMat, chr, chrTrainLogical, param, maxiter,
                         verbose, estimateNormal = estimateNormal, estimatePloidy = estimatePloidy,
                         estimateSubclone = estimateSubclone, estimatePrecision = estimatePrecision,
                         estimateTransition = estimateTransition, estimateInitDist = estimateInitDist)

  # Run Viterbi algorithm
  viterbiResults <- runViterbi(convergedParams, chr)

  # Segment data
  segs <- segmentData(x, validInd, viterbiResults$states, convergedParams)

  # Map state names
  names <- c("HOMD", "HETD", "NEUT", "GAIN", "AMP", "HLAMP", paste0("HLAMP", 2:25))

  id <- names(x)
  copyNumber <- param$jointCNstates[viterbiResults$states]
  subclone.status <- param$jointSCstatus[viterbiResults$states]

  cnaData <- data.frame(
    sample = as.character(id),
    chr = as.character(seqnames(x)),
    start = start(x),
    end = end(x),
    copy.number = copyNumber,
    event = names[copyNumber + 1],
    logR = round(log2(exp(dataMat)), digits = 4),
    subclone.status = as.numeric(subclone.status)
  )

  cnaData <- transform(cnaData,
    start = as.integer(start),
    end = as.integer(end),
    copy.number = as.numeric(copy.number),
    logR = as.numeric(logR),
    subclone.status = as.numeric(subclone.status)
  )

  # Order by chromosome
  chrOrder <- unique(chr)
  cnaData <- cnaData[order(match(cnaData$chr, chrOrder)),]
  cnaData <- cnaData[cnaData$chr %in% chrOrder,]

  # Convert segment median values
  segs$median <- log2(exp(segs$median))
  segs$subclone.status <- param$jointSCstatus[segs$state]

  convergedParams$segs <- segs

  return(list(cna = cnaData, results = convergedParams, viterbiResults = viterbiResults))
}

segmentData <- function(dataGR, validInd, states, convergedParams) {
  includeHOMD <- sum(convergedParams$param$ct == 0) > 0

  names <- if (!includeHOMD) {
    c("HETD", "NEUT", "GAIN", "AMP", "HLAMP", paste0("HLAMP", 2:25))
  } else {
    c("HOMD", "HETD", "NEUT", "GAIN", "AMP", "HLAMP", paste0("HLAMP", 2:25))
  }

  states <- states[validInd]
  jointStates <- convergedParams$param$jointCNstates
  colNames <- c("seqnames", "start", "end", "copy")

  dataIn <- dataGR[validInd, ]
  rleResults <- rle(states)
  numSegs <- length(rleResults$lengths)

  segs <- data.frame(
    chr = character(numSegs),
    start = integer(numSegs),
    end = integer(numSegs),
    state = integer(numSegs),
    event = character(numSegs),
    median = numeric(numSegs),
    copy.number = numeric(numSegs)
  )

  prevInd <- 0
  sampleDF <- as.data.frame(dataIn)

  for (j in 1:numSegs) {
    start <- prevInd + 1
    end <- prevInd + rleResults$lengths[j]
    segDF <- sampleDF[start:end, colNames]
    prevInd <- end

    segs[j, "chr"] <- as.character(segDF[1, "seqnames"])
    segs[j, "start"] <- segDF[1, "start"]
    segs[j, "state"] <- rleResults$values[j]
    if (rleResults$values[j] > 0 && rleResults$values[j] <= nrow(jointStates)) {
    segs[j, "copy.number"] <- jointStates[rleResults$values[j], ]
} else {
    stop(paste("Invalid state index:", rleResults$values[j]))
}


    if (segDF[1, "seqnames"] == segDF[nrow(segDF), "seqnames"]) {
      segs[j, "end"] <- segDF[nrow(segDF), "end"]
      segs[j, "median"] <- round(median(segDF$copy, na.rm = TRUE), digits = 6)
      segs[j, "event"] <- names[segs[j, "copy.number"] + includeHOMD]
    }
  }

  return(segs)
}

#########1#########2#########3#########4#########5#########6#########7#########8

hmmResults.cor <- HMMsegment(tumour_copy, valid, dataType = "copy",
                             chrTrain = chrTrain, maxiter = 50,
                             estimateNormal = estimateNormal, estimatePloidy = estimatePloidy,
                             estimateSubclone = estimateScPrevalence, verbose = TRUE)

head(test)
head(tumour_copy2)

head(tumour_copy3)

class(tumour_copy3$seqnames)


test = HMMsegment(tumour_copy3)

par(mar = c(4, 4, 2, 0))
plotCorrection(tumour_copy, pch = ".")

tumour_segments = HMMsegment(tumour_copy)

default_param <- HMMsegment(tumour_copy, getparam = TRUE)
default_param


#########1#########2#########3#########4#########5#########6#########7#########8

# Single-sample HMM run

ptmTotalSolutions <- proc.time()  # start timer
results <- list()
nComb <- length(normal) * length(ploidy)
loglik <- data.frame(matrix(NA, nrow = nComb, ncol = 7,
              dimnames = list(NULL, c("init", "n_est", "phi_est", "BIC",
                                      "Frac_genome_subclonal", "Frac_CNA_subclonal", "loglik"))))
counter <- 1
mainName <- rep(NA, nComb)

for (n in normal) {
  for (p in ploidy) {
    if (n == 0.95 & p != 2) next

    # Assume tumour_copy is a single-sample object (not a list)
    logR <- data.frame(tumour_copy$copy)  # adjust if needed, e.g. tumour_copy[[1]]$copy
    sel <- valid & chrInd
    param <- getDefaultParameters(logR[sel, , drop = FALSE], maxCN = maxCN,
                                  includeHOMD = includeHOMD, ct.sc = scStates,
                                  ploidy = floor(p), e = txnE, e.same = 50, strength = txnStrength)
    param$phi_0 <- p
    param$n_0 <- n
  }}

## CUSTOM PARAMETER SETTINGS ##
if (is.null(lambda)) {
  # Compute variance per bin (assuming one-sample; original used apply(..., 2, sd))
  logR.var <- 1 / ((sd(unlist(logR), na.rm = TRUE) / sqrt(length(param$ct)))^2)
  param$lambda <- rep(logR.var, length(param$ct))
  param$lambda[param$ct %in% c(2)] <- logR.var
  param$lambda[param$ct %in% c(1, 3)] <- logR.var
  param$lambda[param$ct >= 4] <- logR.var / 5
  param$lambda[param$ct == max(param$ct)] <- logR.var / 15
  param$lambda[param$ct.sc.status] <- logR.var / 10
} else {
  param$lambda[param$ct %in% c(2)] <- lambda[2]
  param$lambda[param$ct %in% c(1)] <- lambda[1]
  param$lambda[param$ct %in% c(3)] <- lambda[3]
  param$lambda[param$ct >= 4] <- lambda[4]
  param$lambda[param$ct == max(param$ct)] <- lambda[2] / 15
  param$lambda[param$ct.sc.status] <- lambda[2] / 10
}
param$alphaLambda <- rep(lambdaScaleHyperParam, length(param$ct))


#########1#########2#########3#########4#########5#########6#########7#########8

#HMMsegment = function(x, validInd = NULL, dataType = "copy", param = NULL,
   # chrTrain = c(1:22), maxiter = 50, estimateNormal = TRUE, estimatePloidy = TRUE,
   # estimatePrecision = TRUE, estimateSubclone = TRUE, estimateTransition = TRUE,
   # estimateInitDist = TRUE, logTransform = FALSE, verbose = TRUE) {

x = list(tumour_copy)

class(x)

chr <- as.factor(seqnames(x[[1]]))
# setup columns for multiple samples #

dataType = "copy"

dataMat <- as.matrix(as.data.frame(lapply(x, function(y) { mcols(x[[1]])[, dataType] })))

head(dataMat)

logTransform = FALSE

# normalize by median and log data #
if (logTransform){
  dataMat <- apply(dataMat, 2, function(x){ log(x / median(x, na.rm = TRUE)) })
}else{
  dataMat <- log(2^dataMat)
}

head(dataMat)
chrTrain

validInd=NULL
## update variable x with loge instead of log2
for (i in 1:length(x)){
  mcols(x[[i]])[, dataType] <- dataMat[, i]
}
if (!is.null(chrTrain)) {
  chrInd <- chr %in% chrTrain
}else{
  chrInd <- !logical(length(chr))
}
if (!is.null(validInd)){
  chrInd <- chrInd & validInd
}

head(chrInd)

param = NULL

if (is.null(param)){
  param <- getDefaultParameters(dataMat[chrInd])
}

print(dim(dataMat))
print(dim(dataMat[chrInd, ]))  # This should return a valid dimension

#if (param$n_0 == 0){
#	param$n_0 <- .Machine$double.eps
#}
####### RUN EM ##########
  convergedParams <- runEM(dataMat, chr, chrInd, param, maxiter,
      verbose, estimateNormal = estimateNormal, estimatePloidy = estimatePloidy,
      estimateSubclone = estimateSubclone, estimatePrecision = estimatePrecision,
      estimateTransition = estimateTransition, estimateInitDist = estimateInitDist)
  # Calculate likelihood using converged params
 # S <- param$numberSamples
 # K <- length(param$ct)
 # KS <- K ^ S
 # py <- matrix(0, KS, nrow(dataMat))
 # iter <- convergedParams$iter
  # lambdasKS <- as.matrix(expand.grid(as.data.frame(convergedParams$lambda[, , iter])))
  # for (ks in 1:KS) {
  #   probs <- tdistPDF(dataMat, convergedParams$mus[ks, , iter], lambdasKS[ks, ], param$nu)
  #   py[ks, ] <- apply(probs, 1, prod) # multiply across samples for each data point to get joint likelihood.
  # }
  #
  viterbiResults <- runViterbi(convergedParams, chr)

  # setup columns for multiple samples #
  segs <- segmentData(x, validInd, viterbiResults$states, convergedParams)
  #output$segs <- processSegments(output$segs, chr, start(x), end(x), x$DataToUse)
  names <- c("HOMD","HETD","NEUT","GAIN","AMP","HLAMP",paste0(rep("HLAMP", 8), 2:25))
  #if (c(0) %in% param$ct){ #if state 0 HOMD is IN params#
  	#names <- c("HOMD", names)
  	# shift states to start at 2 (HETD)
    #tmp <- lapply(segs, function(x){ x$state <- x$state + 1; x})
    #viterbiResults$states <- as.numeric(viterbiResults$states) + 1
	#}
	### PUTTING TOGETHER THE COLUMNS IN THE OUTPUT ###
  cnaList <- list()
  S <- length(x)
  for (s in 1:S){
    id <- names(x)[s]
    copyNumber <- param$jointCNstates[viterbiResults$state, s]
    subclone.status <- param$jointSCstatus[viterbiResults$state, s]
  	cnaList[[id]] <- data.frame(cbind(sample = as.character(id),
                  chr = as.character(seqnames(x[[s]])),
                  start = start(x[[s]]), end = end(x[[s]]),
                  copy.number = copyNumber,
                  event = names[copyNumber + 1],
                  logR = round(log2(exp(dataMat[,s])), digits = 4),
                  subclone.status = as.numeric(subclone.status)
  	))

    cnaList[[id]] <- transform(cnaList[[id]],
                              start = as.integer(as.character(start)),
                              end = as.integer(as.character(end)),
                              copy.number = as.numeric(copy.number),
                              logR = as.numeric(as.character(logR)),
                              subclone.status = as.numeric(subclone.status))

  	## order by chromosome ##
  	chrOrder <- unique(chr) #c(1:22,"X","Y")
  	cnaList[[id]] <- cnaList[[id]][order(match(cnaList[[id]][, "chr"],chrOrder)),]
  	## remove MT chr ##
    cnaList[[id]] <- cnaList[[id]][cnaList[[id]][,"chr"] %in% chrOrder, ]

    ## segment mean loge -> log2
    #segs[[s]]$median.logR <- log2(exp(segs[[s]]$median.logR))
    segs[[s]]$median <- log2(exp(segs[[s]]$median))
    ## add subclone status
    segs[[s]]$subclone.status <-  param$jointSCstatus[segs[[s]]$state, s]
  }
  convergedParams$segs <- segs
  return(list(cna = cnaList, results = convergedParams, viterbiResults = viterbiResults))
}



#########1#########2#########3#########4#########5#########6#########7#########8

## RUN HMM ##
# tumour_copy passed as single sample; adjust if tumour_copy remains a one‐element list:
# e.g., HMMsegment(list(tumour_copy), valid, ...)
hmmResults.cor <- HMMsegment(tumour_copy, valid, dataType = "copy",
                             param = param, chrTrain = chrTrain, maxiter = 50,
                             estimateNormal = estimateNormal, estimatePloidy = estimatePloidy,
                             estimateSubclone = estimateScPrevalence, verbose = TRUE)

test= HMMsegment(tumour_copy)

tc_list <- list(tumour_copy)

tc_list <- list("Sample1" = tumour_copy)

test = HMMsegment(tc_list)

chrTrain2 = c("1","2","3")

hmmResults.cor <- HMMsegment(tc_list, valid, dataType = "copy",
                             param = param, chrTrain = chrTrain, maxiter = 50,
                             estimateNormal = estimateNormal, estimatePloidy = estimatePloidy,
                             estimateSubclone = estimateScPrevalence, verbose = TRUE)

hmmResults.cor <- HMMsegment(tc_list, valid, dataType = "copy",
                             param = param, chrTrain = chrTrain, maxiter = 50)

                            ,
                             estimateNormal = estimateNormal, estimatePloidy = estimatePloidy,
                             estimateSubclone = estimateScPrevalence, verbose = TRUE)


class(tumour_copy)

iter <- hmmResults.cor$results$iter
id <- "sample1"  # set an identifier for the sample

    ## Process segmentation for the single sample ##
    segsS <- hmmResults.cor$results$segs[[1]]
    segsS <- segsS[segsS$chr %in% chrTrain, ]
    segAltInd <- which(segsS$event != "NEUT")
    maxBinLength <- -Inf
    if (length(segAltInd) > 0) {
      maxInd <- which.max(segsS$end[segAltInd] - segsS$start[segAltInd] + 1)
      maxSegRD <- GRanges(seqnames = segsS$chr[segAltInd[maxInd]],
                          ranges = IRanges(start = segsS$start[segAltInd[maxInd]],
                                           end = segsS$end[segAltInd[maxInd]]))
      # If tumour_copy is a single object, use tumour_copy[valid, ]
      hits <- findOverlaps(query = maxSegRD, subject = tumour_copy[valid, ])
      maxBinLength <- length(subjectHits(hits))
    }
    cnaS <- hmmResults.cor$cna[[1]]
    altInd <- cnaS[cnaS$chr %in% chrTrain, "event"] == "NEUT"
    altFrac <- sum(!altInd, na.rm = TRUE) / length(altInd)
    if ((maxBinLength <= minSegmentBins) & (altFrac <= altFracThreshold)) {
      hmmResults.cor$results$n[1, iter] <- 1.0
    }

    # Correct integer copy number based on estimated purity and ploidy
    correctedResults <- correctIntegerCN(cn = hmmResults.cor$cna[[1]],
                                         segs = hmmResults.cor$results$segs[[1]],
                                         purity = 1 - hmmResults.cor$results$n[1, iter],
                                         ploidy = hmmResults.cor$results$phi[1, iter],
                                         cellPrev = 1 - hmmResults.cor$results$sp[1, iter],
                                         maxCNtoCorrect.autosomes = maxCN, maxCNtoCorrect.X = maxCN,
                                         minPurityToCorrect = minTumFracToCorrect,
                                         gender = gender$gender, chrs = chrs,
                                         correctHOMD = includeHOMD)
    hmmResults.cor$results$segs[[1]] <- correctedResults$segs
    hmmResults.cor$cna[[1]] <- correctedResults$cn

    # Plot the solution
    outPlotFile <- paste0(outDir, "/", id, "/", id, "_genomeWide_", "n", n, "-p", p)
    mainName[counter] <- paste0(id, ", n: ", n, ", p: ", p, ", log likelihood: ",
                                signif(hmmResults.cor$results$loglik[iter], digits = 4))
    plotGWSolution(hmmResults.cor, s = 1, outPlotFile = outPlotFile, plotFileType = plotFileType,
                   logR.column = "logR", call.column = "Corrected_Call",
                   plotYLim = plotYLim, estimateScPrevalence = estimateScPrevalence,
                   seqinfo = seqinfo, main = mainName[counter])

    # Store results
    results[[counter]] <- hmmResults.cor
    loglik[counter, "loglik"] <- signif(hmmResults.cor$results$loglik[iter], digits = 4)
    subClonalBinCount <- sum(hmmResults.cor$cna[[1]]$subclone.status)
    fracGenomeSub <- subClonalBinCount / nrow(hmmResults.cor$cna[[1]])
    fracAltSub <- subClonalBinCount / sum(hmmResults.cor$cna[[1]]$copy.number != 2)
    loglik[counter, "Frac_genome_subclonal"] <- signif(fracGenomeSub, digits = 2)
    loglik[counter, "Frac_CNA_subclonal"] <- signif(fracAltSub, digits = 2)
    loglik[counter, "init"] <- paste0("n", n, "-p", p)
    loglik[counter, "n_est"] <- signif(hmmResults.cor$results$n[1, iter], digits = 2)
    loglik[counter, "phi_est"] <- signif(hmmResults.cor$results$phi[1, iter], digits = 4)

    counter <- counter + 1
  }
}


#########1#########2#########3#########4#########5#########6#########7#########8

### RUN HMM ###
## store the results for different normal and ploidy solutions ##
ptmTotalSolutions <- proc.time() # start total timer
results <- list()
loglik <- as.data.frame(matrix(NA, nrow = length(normal) * length(ploidy), ncol = 7,
                 dimnames = list(c(), c("init", "n_est", "phi_est", "BIC",
                 												"Frac_genome_subclonal", "Frac_CNA_subclonal", "loglik"))))
counter <- 1
compNames <- rep(NA, nrow(loglik))
mainName <- rep(NA, length(normal) * length(ploidy))

#### restart for purity and ploidy values ####
for (n in normal){
  for (p in ploidy){
    if (n == 0.95 & p != 2) {
        next
    }
    logR <- as.data.frame(lapply(tumour_copy, function(x) { x$copy })) # NEED TO EXCLUDE CHR X #
    param <- getDefaultParameters(logR[valid & chrInd, , drop=F], maxCN = maxCN, includeHOMD = includeHOMD,
                ct.sc=scStates, ploidy = floor(p), e=txnE, e.same = 50, strength=txnStrength)
    param$phi_0 <- rep(p, numSamples)
    param$n_0 <- rep(n, numSamples)

    ############################################
    ######## CUSTOM PARAMETER SETTINGS #########
    ############################################
    # 0.1x cfDNA #
    if (is.null(lambda)){
			logR.var <- 1 / ((apply(logR, 2, sd, na.rm = TRUE) / sqrt(length(param$ct))) ^ 2)
			param$lambda <- rep(logR.var, length(param$ct))
			param$lambda[param$ct %in% c(2)] <- logR.var
			param$lambda[param$ct %in% c(1,3)] <- logR.var
			param$lambda[param$ct >= 4] <- logR.var / 5
			param$lambda[param$ct == max(param$ct)] <- logR.var / 15
			param$lambda[param$ct.sc.status] <- logR.var / 10
    }else{
			param$lambda[param$ct %in% c(2)] <- lambda[2]
			param$lambda[param$ct %in% c(1)] <- lambda[1]
			param$lambda[param$ct %in% c(3)] <- lambda[3]
			param$lambda[param$ct >= 4] <- lambda[4]
			param$lambda[param$ct == max(param$ct)] <- lambda[2] / 15
			param$lambda[param$ct.sc.status] <- lambda[2] / 10
		}
		param$alphaLambda <- rep(lambdaScaleHyperParam, length(param$ct))
    # 1x bulk tumors #
    #param$lambda[param$ct %in% c(2)] <- 2000
    #param$lambda[param$ct %in% c(1)] <- 1750
    #param$lambda[param$ct %in% c(3)] <- 1750
    #param$lambda[param$ct >= 4] <- 1500
    #param$lambda[param$ct == max(param$ct)] <- 1000 / 25
		#param$lambda[param$ct.sc.status] <- 1000 / 75
		#param$alphaLambda[param$ct.sc.status] <- 4
		#param$alphaLambda[param$ct %in% c(1,3)] <- 5
		#param$alphaLambda[param$ct %in% c(2)] <- 5
		#param$alphaLambda[param$ct == max(param$ct)] <- 4

		#############################################
		################ RUN HMM ####################
		#############################################
    hmmResults.cor <- HMMsegment(tumour_copy, valid, dataType = "copy",
                                 param = param, chrTrain = chrTrain, maxiter = 50,
                                 estimateNormal = estimateNormal, estimatePloidy = estimatePloidy,
                                 estimateSubclone = estimateScPrevalence, verbose = TRUE)

    for (s in 1:numSamples){
  		iter <- hmmResults.cor$results$iter
  		id <- names(hmmResults.cor$cna)[s]

  		## convert full diploid solution (of chrs to train) to have 1.0 normal or 0.0 purity
  		## check if there is an altered segment that has at least a minimum # of bins
  		segsS <- hmmResults.cor$results$segs[[s]]
  		segsS <- segsS[segsS$chr %in% chrTrain, ]
  		segAltInd <- which(segsS$event != "NEUT")
  		maxBinLength = -Inf
  		if (sum(segAltInd) > 0){
  			maxInd <- which.max(segsS$end[segAltInd] - segsS$start[segAltInd] + 1)
  			maxSegRD <- GRanges(seqnames=segsS$chr[segAltInd[maxInd]],
  								ranges=IRanges(start=segsS$start[segAltInd[maxInd]], end=segsS$end[segAltInd[maxInd]]))
  			hits <- findOverlaps(query=maxSegRD, subject=tumour_copy[[s]][valid, ])
  			maxBinLength <- length(subjectHits(hits))
  		}
  		## check if there are proportion of total bins altered
  		# if segment size smaller than minSegmentBins, but altFrac > altFracThreshold, then still estimate TF
  		cnaS <- hmmResults.cor$cna[[s]]
  		altInd <- cnaS[cnaS$chr %in% chrTrain, "event"] == "NEUT"
  		altFrac <- sum(!altInd, na.rm=TRUE) / length(altInd)
  		if ((maxBinLength <= minSegmentBins) & (altFrac <= altFracThreshold)){
  			hmmResults.cor$results$n[s, iter] <- 1.0
  		}

      # correct integer copy number based on estimated purity and ploidy
      correctedResults <- correctIntegerCN(cn = hmmResults.cor$cna[[s]],
            segs = hmmResults.cor$results$segs[[s]],
            purity = 1 - hmmResults.cor$results$n[s, iter], ploidy = hmmResults.cor$results$phi[s, iter],
            cellPrev = 1 - hmmResults.cor$results$sp[s, iter],
            maxCNtoCorrect.autosomes = maxCN, maxCNtoCorrect.X = maxCN, minPurityToCorrect = minTumFracToCorrect,
            gender = gender$gender, chrs = chrs, correctHOMD = includeHOMD)
      hmmResults.cor$results$segs[[s]] <- correctedResults$segs
      hmmResults.cor$cna[[s]] <- correctedResults$cn

      	## plot solution ##
  		outPlotFile <- paste0(outDir, "/", id, "/", id, "_genomeWide_", "n", n, "-p", p)
  		mainName[counter] <- paste0(id, ", n: ", n, ", p: ", p, ", log likelihood: ", signif(hmmResults.cor$results$loglik[hmmResults.cor$results$iter], digits = 4))
  		plotGWSolution(hmmResults.cor, s=s, outPlotFile=outPlotFile, plotFileType=plotFileType,
            logR.column = "logR", call.column = "Corrected_Call",
  					 plotYLim=plotYLim, estimateScPrevalence=estimateScPrevalence, seqinfo=seqinfo, main=mainName[counter])
    }
    iter <- hmmResults.cor$results$iter
    results[[counter]] <- hmmResults.cor
    loglik[counter, "loglik"] <- signif(hmmResults.cor$results$loglik[iter], digits = 4)
    subClonalBinCount <- unlist(lapply(hmmResults.cor$cna, function(x){ sum(x$subclone.status) }))
    fracGenomeSub <- subClonalBinCount / unlist(lapply(hmmResults.cor$cna, function(x){ nrow(x) }))
    fracAltSub <- subClonalBinCount / unlist(lapply(hmmResults.cor$cna, function(x){ sum(x$copy.number != 2) }))
    fracAltSub <- lapply(fracAltSub, function(x){if (is.na(x)){0}else{x}})
    loglik[counter, "Frac_genome_subclonal"] <- paste0(signif(fracGenomeSub, digits=2), collapse=",")
    loglik[counter, "Frac_CNA_subclonal"] <- paste0(signif(as.numeric(fracAltSub), digits=2), collapse=",")
    loglik[counter, "init"] <- paste0("n", n, "-p", p)
    loglik[counter, "n_est"] <- paste(signif(hmmResults.cor$results$n[, iter], digits = 2), collapse = ",")
    loglik[counter, "phi_est"] <- paste(signif(hmmResults.cor$results$phi[, iter], digits = 4), collapse = ",")

    counter <- counter + 1
  }
}

#########1#########2#########3#########4#########5#########6#########7#########8



tumour_copy_norm




normal_copy
tumour_copy[[id]] <- normalizeByPanelOrMatchedNormal(tumour_copy[[id]], chrs = chrs,
                                                     normal_panel = normal_panel, normal_copy = normal_copy,
                                                     gender = gender$gender, normalizeMaleX = normalizeMaleX)

### OUTPUT FILE ###
### PUTTING TOGETHER THE COLUMNS IN THE OUTPUT ###
outMat <- as.data.frame(tumour_copy[[id]])
#outMat <- outMat[,c(1,2,3,12)]
outMat <- outMat[,c("seqnames","start","end","copy")]
colnames(outMat) <- c("chr","start","end","log2_TNratio_corrected")
outFile <- paste0(outDir,"/",id,".correctedDepth.txt")
message(paste("Outputting to:", outFile))
write.table(outMat, file=outFile, row.names=F, col.names=T, quote=F, sep="\t")

#########1#########2#########3#########4#########5#########6#########7#########8

# Helper function to normalize tumour copy
normalize_tumour <- function(tumour_copy, chrs, normal_panel, normal_copy, gender, normalizeMaleX) {
  message("Normalizing tumour data...")
  return(normalizeByPanelOrMatchedNormal(tumour_copy, chrs = chrs, normal_panel = normal_panel,
                                         normal_copy = normal_copy, gender = gender,
                                         normalizeMaleX = normalizeMaleX))
}

normalize_tumour(test, chrs, normal_panel, normal_copy, gender, normalizeMaleX)

# Main function
process_single_sample <- function(id, tumour_file, normal_file, outDir, gcWig, mapWig,
                                  chrs, centromere, flankLength, targetedSequences,
                                  chrXMedianForMale, genomeStyle, fracReadsInChrYForMale,
                                  chrNormalize, minMapScore, normal_panel, normalizeMaleX) {

  # Step 1: Create output directory
  dir_path <- create_output_dir(outDir, id)

  # Step 2: Load tumour data
  tumour_reads <- load_wig_file(tumour_file)

  # Step 3: Load GC and mappability files
  gc <- load_wig_file(gcWig)
  map <- load_wig_file(mapWig)

  # Step 4: Process tumour read counts
  tumour_counts <- process_read_counts(tumour_reads, chrs, gc, map, centromere, flankLength,
                                       targetedSequences, chrXMedianForMale, genomeStyle,
                                       fracReadsInChrYForMale, chrNormalize, minMapScore)
  tumour_copy <- tumour_counts$counts
  gender <- tumour_counts$gender

  # Step 5: Load normal data if provided
  normal_copy <- if (!is.null(normal_file) && !normal_file %in% c("None", "NULL")) {
    normal_reads <- load_wig_file(normal_file, "normal")
    normal_counts <- process_read_counts(normal_reads, chrs, gc, map, centromere, flankLength,
                                         targetedSequences, chrXMedianForMale, genomeStyle,
                                         fracReadsInChrYForMale, chrNormalize, minMapScore)
    normal_counts$counts
  } else NULL

  # Step 6: Normalize tumour data
  tumour_copy <- normalize_tumour(tumour_copy, chrs, normal_panel, normal_copy, gender$gender, normalizeMaleX)

  # Step 7: Output results
  outMat <- as.data.frame(tumour_copy)[, c("seqnames", "start", "end", "copy")]
  colnames(outMat) <- c("chr", "start", "end", "log2_TNratio_corrected")

  outFile <- file.path(dir_path, paste0(id, ".correctedDepth.txt"))
  message("Outputting to:", outFile)
  write.table(outMat, file = outFile, row.names = FALSE, col.names = TRUE, quote = FALSE, sep = "\t")
}

# Example usage:
# process_single_sample(id = "sample1", tumour_file = "tumour.wig", normal_file = "normal.wig",
#                       outDir = "/output", gcWig = "gc.wig", mapWig = "map.wig", chrs = ...,
#                       centromere = ..., flankLength = ..., targetedSequences = ...,
#                       chrXMedianForMale = ..., genomeStyle = ..., fracReadsInChrYForMale = ...,
#                       chrNormalize = ..., minMapScore = ..., normal_panel = ..., normalizeMaleX = ...)

pon = "/home/jeszyman/repos/ichorCNA/inst/extdata/HD_ULP_PoN_hg38_1Mb_median_normAutosome_median.rds"

test = process_single_sample(id, wigFiles[1,2], normal_file, outDir, gcWig, mapWig, chrs, centromere, flankLength, pon, -0.5, "UCSC", 0.002, chrNormalize, minMapScore, NULL, TRUE)


chrNormalize
minMapScore
normal_panel
normalizeMaleX
#########1#########2#########3#########4#########5#########6#########7#########8


chrInd <- as.character(seqnames(tumour_copy[[1]])) %in% chrTrain
## get positions that are valid
valid <- tumour_copy[[1]]$valid
if (length(tumour_copy) >= 2) {
  for (i in 2:length(tumour_copy)){
    valid <- valid & tumour_copy[[i]]$valid
  }
}



save.image(outImage)


### RUN HMM ###
## store the results for different normal and ploidy solutions ##
ptmTotalSolutions <- proc.time() # start total timer
results <- list()
loglik <- as.data.frame(matrix(NA, nrow = length(normal) * length(ploidy), ncol = 7,
                 dimnames = list(c(), c("init", "n_est", "phi_est", "BIC",
                 												"Frac_genome_subclonal", "Frac_CNA_subclonal", "loglik"))))
counter <- 1
compNames <- rep(NA, nrow(loglik))
mainName <- rep(NA, length(normal) * length(ploidy))
#### restart for purity and ploidy values ####
for (n in normal){
  for (p in ploidy){
    if (n == 0.95 & p != 2) {
        next
    }
    logR <- as.data.frame(lapply(tumour_copy, function(x) { x$copy })) # NEED TO EXCLUDE CHR X #
    param <- getDefaultParameters(logR[valid & chrInd, , drop=F], maxCN = maxCN, includeHOMD = includeHOMD,
                ct.sc=scStates, ploidy = floor(p), e=txnE, e.same = 50, strength=txnStrength)
    param$phi_0 <- rep(p, numSamples)
    param$n_0 <- rep(n, numSamples)

    ############################################
    ######## CUSTOM PARAMETER SETTINGS #########
    ############################################
    # 0.1x cfDNA #
    if (is.null(lambda)){
			logR.var <- 1 / ((apply(logR, 2, sd, na.rm = TRUE) / sqrt(length(param$ct))) ^ 2)
			param$lambda <- rep(logR.var, length(param$ct))
			param$lambda[param$ct %in% c(2)] <- logR.var
			param$lambda[param$ct %in% c(1,3)] <- logR.var
			param$lambda[param$ct >= 4] <- logR.var / 5
			param$lambda[param$ct == max(param$ct)] <- logR.var / 15
			param$lambda[param$ct.sc.status] <- logR.var / 10
    }else{
			param$lambda[param$ct %in% c(2)] <- lambda[2]
			param$lambda[param$ct %in% c(1)] <- lambda[1]
			param$lambda[param$ct %in% c(3)] <- lambda[3]
			param$lambda[param$ct >= 4] <- lambda[4]
			param$lambda[param$ct == max(param$ct)] <- lambda[2] / 15
			param$lambda[param$ct.sc.status] <- lambda[2] / 10
		}
		param$alphaLambda <- rep(lambdaScaleHyperParam, length(param$ct))
    # 1x bulk tumors #
    #param$lambda[param$ct %in% c(2)] <- 2000
    #param$lambda[param$ct %in% c(1)] <- 1750
    #param$lambda[param$ct %in% c(3)] <- 1750
    #param$lambda[param$ct >= 4] <- 1500
    #param$lambda[param$ct == max(param$ct)] <- 1000 / 25
		#param$lambda[param$ct.sc.status] <- 1000 / 75
		#param$alphaLambda[param$ct.sc.status] <- 4
		#param$alphaLambda[param$ct %in% c(1,3)] <- 5
		#param$alphaLambda[param$ct %in% c(2)] <- 5
		#param$alphaLambda[param$ct == max(param$ct)] <- 4

		#############################################
		################ RUN HMM ####################
		#############################################
    hmmResults.cor <- HMMsegment(tumour_copy, valid, dataType = "copy",
                                 param = param, chrTrain = chrTrain, maxiter = 50,
                                 estimateNormal = estimateNormal, estimatePloidy = estimatePloidy,
                                 estimateSubclone = estimateScPrevalence, verbose = TRUE)

    for (s in 1:numSamples){
  		iter <- hmmResults.cor$results$iter
  		id <- names(hmmResults.cor$cna)[s]

  		## convert full diploid solution (of chrs to train) to have 1.0 normal or 0.0 purity
  		## check if there is an altered segment that has at least a minimum # of bins
  		segsS <- hmmResults.cor$results$segs[[s]]
  		segsS <- segsS[segsS$chr %in% chrTrain, ]
  		segAltInd <- which(segsS$event != "NEUT")
  		maxBinLength = -Inf
  		if (sum(segAltInd) > 0){
  			maxInd <- which.max(segsS$end[segAltInd] - segsS$start[segAltInd] + 1)
  			maxSegRD <- GRanges(seqnames=segsS$chr[segAltInd[maxInd]],
  								ranges=IRanges(start=segsS$start[segAltInd[maxInd]], end=segsS$end[segAltInd[maxInd]]))
  			hits <- findOverlaps(query=maxSegRD, subject=tumour_copy[[s]][valid, ])
  			maxBinLength <- length(subjectHits(hits))
  		}
  		## check if there are proportion of total bins altered
  		# if segment size smaller than minSegmentBins, but altFrac > altFracThreshold, then still estimate TF
  		cnaS <- hmmResults.cor$cna[[s]]
  		altInd <- cnaS[cnaS$chr %in% chrTrain, "event"] == "NEUT"
  		altFrac <- sum(!altInd, na.rm=TRUE) / length(altInd)
  		if ((maxBinLength <= minSegmentBins) & (altFrac <= altFracThreshold)){
  			hmmResults.cor$results$n[s, iter] <- 1.0
  		}

      # correct integer copy number based on estimated purity and ploidy
      correctedResults <- correctIntegerCN(cn = hmmResults.cor$cna[[s]],
            segs = hmmResults.cor$results$segs[[s]],
            purity = 1 - hmmResults.cor$results$n[s, iter], ploidy = hmmResults.cor$results$phi[s, iter],
            cellPrev = 1 - hmmResults.cor$results$sp[s, iter],
            maxCNtoCorrect.autosomes = maxCN, maxCNtoCorrect.X = maxCN, minPurityToCorrect = minTumFracToCorrect,
            gender = gender$gender, chrs = chrs, correctHOMD = includeHOMD)
      hmmResults.cor$results$segs[[s]] <- correctedResults$segs
      hmmResults.cor$cna[[s]] <- correctedResults$cn

      	## plot solution ##
  		outPlotFile <- paste0(outDir, "/", id, "/", id, "_genomeWide_", "n", n, "-p", p)
  		mainName[counter] <- paste0(id, ", n: ", n, ", p: ", p, ", log likelihood: ", signif(hmmResults.cor$results$loglik[hmmResults.cor$results$iter], digits = 4))
  		plotGWSolution(hmmResults.cor, s=s, outPlotFile=outPlotFile, plotFileType=plotFileType,
            logR.column = "logR", call.column = "Corrected_Call",
  					 plotYLim=plotYLim, estimateScPrevalence=estimateScPrevalence, seqinfo=seqinfo, main=mainName[counter])
    }
    iter <- hmmResults.cor$results$iter
    results[[counter]] <- hmmResults.cor
    loglik[counter, "loglik"] <- signif(hmmResults.cor$results$loglik[iter], digits = 4)
    subClonalBinCount <- unlist(lapply(hmmResults.cor$cna, function(x){ sum(x$subclone.status) }))
    fracGenomeSub <- subClonalBinCount / unlist(lapply(hmmResults.cor$cna, function(x){ nrow(x) }))
    fracAltSub <- subClonalBinCount / unlist(lapply(hmmResults.cor$cna, function(x){ sum(x$copy.number != 2) }))
    fracAltSub <- lapply(fracAltSub, function(x){if (is.na(x)){0}else{x}})
    loglik[counter, "Frac_genome_subclonal"] <- paste0(signif(fracGenomeSub, digits=2), collapse=",")
    loglik[counter, "Frac_CNA_subclonal"] <- paste0(signif(as.numeric(fracAltSub), digits=2), collapse=",")
    loglik[counter, "init"] <- paste0("n", n, "-p", p)
    loglik[counter, "n_est"] <- paste(signif(hmmResults.cor$results$n[, iter], digits = 2), collapse = ",")
    loglik[counter, "phi_est"] <- paste(signif(hmmResults.cor$results$phi[, iter], digits = 4), collapse = ",")

    counter <- counter + 1
  }
}
## get total time for all solutions ##
elapsedTimeSolutions <- proc.time() - ptmTotalSolutions
message("Total ULP-WGS HMM Runtime: ", format(elapsedTimeSolutions[3] / 60, digits = 2), " min.")


### SAVE R IMAGE ###
save.image(outImage)
#save(tumour_copy, results, loglik, file=paste0(outDir,"/",id,".RData"))

### SELECT SOLUTION WITH LARGEST LIKELIHOOD ###
loglik <- loglik[!is.na(loglik$init), ]
if (estimateScPrevalence){ ## sort but excluding solutions with too large % subclonal
	fracInd <- which(loglik[, "Frac_CNA_subclonal"] <= maxFracCNASubclone &
						 		   loglik[, "Frac_genome_subclonal"] <= maxFracGenomeSubclone)
	if (length(fracInd) > 0){ ## if there is a solution satisfying % subclonal
		ind <- fracInd[order(loglik[fracInd, "loglik"], decreasing=TRUE)]
	}else{ # otherwise just take largest likelihood
		ind <- order(as.numeric(loglik[, "loglik"]), decreasing=TRUE)
	}
}else{#sort by likelihood only
  ind <- order(as.numeric(loglik[, "loglik"]), decreasing=TRUE)
}

#new loop by order of solutions (ind)
outPlotFile <- paste0(outDir, "/", id, "/", id, "_genomeWide_all_sols")
for(i in 1:length(ind)) {
  hmmResults.cor <- results[[ind[i]]]
  turnDevOff <- FALSE
  turnDevOn <- FALSE
  if (i == 1){
  	turnDevOn <- TRUE
  }
  if (i == length(ind)){
  	turnDevOff <- TRUE
  }
  plotGWSolution(hmmResults.cor, s=s, outPlotFile=outPlotFile, plotFileType="pdf",
                     logR.column = "logR", call.column = "Corrected_Call",
                     plotYLim=plotYLim, estimateScPrevalence=estimateScPrevalence,
                     seqinfo = seqinfo,
                     turnDevOn = turnDevOn, turnDevOff = turnDevOff, main=mainName[ind[i]])
}

hmmResults.cor <- results[[ind[1]]]
hmmResults.cor$results$loglik <- as.data.frame(loglik)
hmmResults.cor$results$gender <- gender$gender
hmmResults.cor$results$chrYCov <- gender$chrYCovRatio
hmmResults.cor$results$chrXMedian <- gender$chrXMedian
hmmResults.cor$results$coverage <- coverage

outputHMM(cna = hmmResults.cor$cna, segs = hmmResults.cor$results$segs,
                      results = hmmResults.cor$results, patientID = patientID, outDir=outDir)
outFile <- paste0(outDir, "/", patientID, ".params.txt")
outputParametersToFile(hmmResults.cor, file = outFile)

## plot solutions for all samples
plotSolutions(hmmResults.cor, tumour_copy, chrs, outDir, numSamples=numSamples,
              logR.column = "logR", call.column = "Corrected_Call",
              plotFileType=plotFileType, plotYLim=plotYLim, seqinfo = seqinfo,
              estimateScPrevalence=estimateScPrevalence, maxCN=maxCN)
#+end_src
#+begin_src R
# file:   ichorCNA.R
# author: Gavin Ha, Ph.D.
#               Dana-Farber Cancer Institute
#               Broad Institute
# contact: <gavinha@broadinstitute.org>
#         Justin Rhoades
#               Broad Institute
# contact: <rhoades@broadinstitute.org>

# ichorCNA: https://github.com/broadinstitute/ichorCNA
# HMMcopy website: http://compbio.bccrc.ca/software/hmmcopy/ and https://www.bioconductor.org/packages/release/bioc/html/HMMcopy.html
# date:   August 1, 2018
# description: Hidden Markov model (HMM) to analyze Ultra-low pass whole genome sequencing (ULP-WGS) data.
# This script is the main script to run the HMM.

library(optparse)

option_list <- list(
  make_option(c("--WIG"), type = "character", help = "Path to tumor WIG file. Required."),
  make_option(c("--NORMWIG"), type = "character", default=NULL, help = "Path to normal WIG file. Default: [%default]"),
  make_option(c("--gcWig"), type = "character", help = "Path to GC-content WIG file; Required"),
  make_option(c("--mapWig"), type = "character", default=NULL, help = "Path to mappability score WIG file. Default: [%default]"),
  make_option(c("--normalPanel"), type="character", default=NULL, help="Median corrected depth from panel of normals. Default: [%default]"),
  make_option(c("--exons.bed"), type = "character", default=NULL, help = "Path to bed file containing exon regions. Default: [%default]"),
  make_option(c("--id"), type = "character", default="test", help = "Patient ID. Default: [%default]"),
  make_option(c("--centromere"), type="character", default=NULL, help = "File containing Centromere locations; if not provided then will use hg19 version from ichorCNA package. Default: [%default]"),
  make_option(c("--rmCentromereFlankLength"), type="numeric", default=1e5, help="Length of region flanking centromere to remove. Default: [%default]"),
  make_option(c("--normal"), type="character", default="0.5", help = "Initial normal contamination; can be more than one value if additional normal initializations are desired. Default: [%default]"),
  make_option(c("--scStates"), type="character", default="NULL", help = "Subclonal states to consider. Default: [%default]"),
  make_option(c("--coverage"), type="numeric", default=NULL, help = "PICARD sequencing coverage. Default: [%default]"),
  make_option(c("--lambda"), type="character", default="NULL", help="Initial Student's t precision; must contain 4 values (e.g. c(1500,1500,1500,1500)); if not provided then will automatically use based on variance of data. Default: [%default]"),
  make_option(c("--lambdaScaleHyperParam"), type="numeric", default=3, help="Hyperparameter (scale) for Gamma prior on Student's-t precision. Default: [%default]"),
  #	make_option(c("--kappa"), type="character", default=50, help="Initial state distribution"),
  make_option(c("--ploidy"), type="character", default="2", help = "Initial tumour ploidy; can be more than one value if additional ploidy initializations are desired. Default: [%default]"),
  make_option(c("--maxCN"), type="numeric", default=7, help = "Total clonal CN states. Default: [%default]"),
  make_option(c("--estimateNormal"), type="logical", default=TRUE, help = "Estimate normal. Default: [%default]"),
  make_option(c("--estimateScPrevalence"), type="logical", default=TRUE, help = "Estimate subclonal prevalence. Default: [%default]"),
  make_option(c("--estimatePloidy"), type="logical", default=TRUE, help = "Estimate tumour ploidy. Default: [%default]"),
  make_option(c("--maxFracCNASubclone"), type="numeric", default=0.7, help="Exclude solutions with fraction of subclonal events greater than this value. Default: [%default]"),
  make_option(c("--maxFracGenomeSubclone"), type="numeric", default=0.5, help="Exclude solutions with subclonal genome fraction greater than this value. Default: [%default]"),
  make_option(c("--minSegmentBins"), type="numeric", default=50, help="Minimum number of bins for largest segment threshold required to estimate tumor fraction; if below this threshold, then will be assigned zero tumor fraction."),
  make_option(c("--altFracThreshold"), type="numeric", default=0.05, help="Minimum proportion of bins altered required to estimate tumor fraction; if below this threshold, then will be assigned zero tumor fraction. Default: [%default]"),
  make_option(c("--chrNormalize"), type="character", default="c(1:22)", help = "Specify chromosomes to normalize GC/mappability biases. Default: [%default]"),
  make_option(c("--chrTrain"), type="character", default="c(1:22)", help = "Specify chromosomes to estimate params. Default: [%default]"),
  make_option(c("--chrs"), type="character", default="c(1:22,\"X\")", help = "Specify chromosomes to analyze. Default: [%default]"),
  make_option(c("--genomeStyle"), type = "character", default = "NCBI", help = "NCBI or UCSC chromosome naming convention; use UCSC if desired output is to have \"chr\" string. [Default: %default]"),
  make_option(c("--normalizeMaleX"), type="logical", default=TRUE, help = "If male, then normalize chrX by median. Default: [%default]"),
  make_option(c("--fracReadsInChrYForMale"), type="numeric", default=0.001, help = "Threshold for fraction of reads in chrY to assign as male. Default: [%default]"),
  make_option(c("--includeHOMD"), type="logical", default=FALSE, help="If FALSE, then exclude HOMD state. Useful when using large bins (e.g. 1Mb). Default: [%default]"),
  make_option(c("--txnE"), type="numeric", default=0.9999999, help = "Self-transition probability. Increase to decrease number of segments. Default: [%default]"),
  make_option(c("--txnStrength"), type="numeric", default=1e7, help = "Transition pseudo-counts. Exponent should be the same as the number of decimal places of --txnE. Default: [%default]"),
  	make_option(c("--plotFileType"), type="character", default="pdf", help = "File format for output plots. Default: [%default]"),
	make_option(c("--plotYLim"), type="character", default="c(-2,2)", help = "ylim to use for chromosome plots. Default: [%default]"),
  make_option(c("--outDir"), type="character", default="./", help = "Output Directory. Default: [%default]"),
  make_option(c("--libdir"), type = "character", default=NULL, help = "Script library path. Usually exclude this argument unless custom modifications have been made to the ichorCNA R package code and the user would like to source those R files. Default: [%default]")
)

arguments <- c("--id=TEST",
                "--WIG=./tests/wigs/test_ncbi.wig",
                "--gcWig=./ichorCNA.v0.2.0/inst/extdata/gc_hg38_1000kb.wig",
                "--mapWig=./ichorCNA.v0.2.0/inst/extdata/map_hg38_1000kb.wig",
                "--centromere=./ichorCNA.v0.2.0/inst/extdata/GRCh38.GCA_000001405.2_centromere_acen.txt",
                "--normal=c(0.95, 0.99, 0.995, 0.999)",
                "--normalPanel=./ichorCNA.v0.2.0/inst/extdata/HD_ULP_PoN_1Mb_median_normAutosome_mapScoreFiltered_median.rds",
                "--ploidy=c(2)",
                "--maxCN=3",
                "--estimateScPrevalence=FALSE",
                "--outDir=./test/ichor",
                "--libdir=./ichorCNA.v0.2.0")

parseobj <- OptionParser(option_list=option_list)
opt <- parse_args(parseobj, args = arguments)
#########1#########2#########3#########4#########5#########6#########7#########8
print(opt)
options(scipen=0, stringsAsFactors=F)

library(HMMcopy)
library(GenomeInfoDb)
options(stringsAsFactors=FALSE)
options(bitmapType='cairo')

patientID <- opt$id
tumour_file <- opt$WIG
normal_file <- opt$NORMWIG
gcWig <- opt$gcWig
mapWig <- opt$mapWig
normal_panel <- opt$normalPanel
exons.bed <- opt$exons.bed  # "0" if none specified
centromere <- opt$centromere
flankLength <- opt$rmCentromereFlankLength
normal <- eval(parse(text = opt$normal))
scStates <- eval(parse(text = opt$scStates))
lambda <- eval(parse(text = opt$lambda))
lambdaScaleHyperParam <- opt$lambdaScaleHyperParam
estimateNormal <- opt$estimateNormal
estimatePloidy <- opt$estimatePloidy
estimateScPrevalence <- opt$estimateScPrevalence
maxFracCNASubclone <- opt$maxFracCNASubclone
maxFracGenomeSubclone <- opt$maxFracGenomeSubclone
minSegmentBins <- opt$minSegmentBins
altFracThreshold <- opt$altFracThreshold
ploidy <- eval(parse(text = opt$ploidy))
coverage <- opt$coverage
maxCN <- opt$maxCN
txnE <- opt$txnE
txnStrength <- opt$txnStrength
normalizeMaleX <- as.logical(opt$normalizeMaleX)
includeHOMD <- as.logical(opt$includeHOMD)
fracReadsInChrYForMale <- opt$fracReadsInChrYForMale
outDir <- opt$outDir
libdir <- opt$libdir
plotFileType <- opt$plotFileType
plotYLim <- eval(parse(text=opt$plotYLim))
gender <- NULL
outImage <- paste0(outDir,"/", patientID,".RData")
genomeStyle <- opt$genomeStyle
chrs <- as.character(eval(parse(text = opt$chrs)))
chrTrain <- as.character(eval(parse(text=opt$chrTrain)));
chrNormalize <- as.character(eval(parse(text=opt$chrNormalize)));
seqlevelsStyle(chrs) <- genomeStyle
seqlevelsStyle(chrNormalize) <- genomeStyle
seqlevelsStyle(chrTrain) <- genomeStyle


if (!is.null(libdir) && libdir != "None"){
	source(paste0(libdir,"/R/utils.R"))
	source(paste0(libdir,"/R/segmentation.R"))
	source(paste0(libdir,"/R/EM.R"))
	source(paste0(libdir,"/R/output.R"))
	source(paste0(libdir,"/R/plotting.R"))
} else {
    library(ichorCNA)
}
if (substr(tumour_file,nchar(tumour_file)-2,nchar(tumour_file)) == "wig") {
  wigFiles <- data.frame(cbind(patientID, tumour_file))
} else {
  wigFiles <- read.delim(tumour_file, header=F, as.is=T)
}

## FILTER BY EXONS IF PROVIDED ##
## add gc and map to RangedData object ##
if (is.null(exons.bed) || exons.bed == "None" || exons.bed == "NULL"){
  targetedSequences <- NULL
}else{
  targetedSequences <- read.delim(exons.bed, header=T, sep="\t")
}

## load PoN
if (is.null(normal_panel) || normal_panel == "None" || normal_panel == "NULL"){
	normal_panel <- NULL
}

if (is.null(centromere) || centromere == "None" || centromere == "NULL"){ # no centromere file provided
	centromere <- system.file("extdata", "GRCh37.p13_centromere_UCSC-gapTable.txt",
			package = "ichorCNA")
}

centromere <- read.delim(centromere,header=T,stringsAsFactors=F,sep="\t")
save.image(outImage)

#########1#########2#########3#########4#########5#########6#########7#########8


numSamples <- nrow(wigFiles)
message("Number of samples: ", numSamples)


for (i in 1:numSamples) {
  id <- wigFiles[i, 1]
  dir.create(paste0(outDir, "/", id, "/"), recursive = TRUE)
  message("Created directory for ID: ", id)

  ## Load tumour data
  message("Loading tumor file: ", wigFiles[i, 2])
  tumour_reads <- wigToRangedData(wigFiles[i, 2])
  message("Tumor reads: ", str(head(tumour_reads)))
}


binSize <- as.data.frame(tumour_reads[1,])$width
message("Bin size: ", binSize)

message("Loading GC data from: ", gcWig)
gc <- wigToRangedData(gcWig)
message("GC data: ", str(head(gc)))

if (is.null(mapWig) || mapWig == "None" || mapWig == "NULL") {
  message("No mappability wig file input.")
  map <- NULL
} else {
  message("Loading map data from: ", mapWig)
  map <- wigToRangedData(mapWig)
  message("Map data: ", str(head(map)))
}

chrs <- paste0("chr", chrs)

genomeStyle="UCSC"

if (any(seqlevelsStyle(tumour_reads) != "UCSC")) {
  seqlevelsStyle(tumour_reads) <- "UCSC"
}


library(GenomicRanges)

# Convert `tumour_reads` and others to `GRanges`
tumour_reads_gr <- GRanges(seqnames = tumour_reads$chr,
                           ranges = IRanges(start = tumour_reads$start,
                                            end = tumour_reads$end),
                           value = tumour_reads$value)

gc_gr <- GRanges(seqnames = gc$chr,
                 ranges = IRanges(start = gc$start,
                                  end = gc$end),
                 value = gc$value)

if (!is.null(map)) {
  map_gr <- GRanges(seqnames = map$chr,
                    ranges = IRanges(start = map$start,
                                     end = map$end),
                    value = map$value)
}

centromere_gr <- GRanges(seqnames = centromere$Chr,
                         ranges = IRanges(start = centromere$Start,
                                          end = centromere$End),
                         gapType = centromere$GapType)


seqlevelsStyle(tumour_reads_gr) <- "UCSC"
seqlevelsStyle(gc_gr) <- "UCSC"
if (exists("map_gr")) seqlevelsStyle(map_gr) <- "UCSC"
seqlevelsStyle(centromere_gr) <- "UCSC"


message("Correcting Tumour with genomeStyle: ", genomeStyle)


tumour_reads_gr <- GRanges(seqnames = tumour_reads$chr,
                           ranges = IRanges(start = tumour_reads$start,
                                            end = tumour_reads$end),
                           value = tumour_reads$value)
message("Seqlevels for tumour_reads_gr: ", seqlevels(tumour_reads_gr))

chrs



counts <- loadReadCountsFromWig(tumour_reads_gr, chrs = chrs_gr, gc = gc_gr, map = map_gr,
                                centromere = centromere_gr, flankLength = flankLength,
                                targetedSequences = targetedSequences,
                                genomeStyle = genomeStyle,
                                chrNormalize = chrNormalize, mapScoreThres = 0.9)

if (!is.null(counts)) {
  message("Counts loaded. Gender: ", counts$gender)
} else {
  stop("Failed to load counts from tumour.")
}


## LOAD IN WIG FILES ##
numSamples <- nrow(wigFiles)
tumour_counts <- list()
tumour_copy <- list()
for (i in 1:numSamples) {
  id <- wigFiles[i,1]
  ## create output directories for each sample ##
  dir.create(paste0(outDir, "/", id, "/"), recursive = TRUE)
  ### LOAD TUMOUR AND NORMAL FILES ###
  message("Loading tumour file:", wigFiles[i,1])
  tumour_reads <- wigToRangedData(wigFiles[i,2])

  ## LOAD GC/MAP WIG FILES ###
  # find the bin size and load corresponding wig files #
  binSize <- as.data.frame(tumour_reads[1,])$width
  message("Reading GC and mappability files")
  if (is.null(gcWig) || gcWig == "None" || gcWig == "NULL"){
      stop("GC wig file is required")
  }
  gc <- wigToRangedData(gcWig)
  if (is.null(mapWig) || mapWig == "None" || mapWig == "NULL"){
      message("No mappability wig file input, excluding from correction")
      map <- NULL
  } else {
      map <- wigToRangedData(mapWig)
  }
  message("Correcting Tumour")

  counts <- loadReadCountsFromWig(tumour_reads, chrs = chrs, gc = gc, map = map,
                                       centromere = centromere, flankLength = flankLength,
                                       targetedSequences = targetedSequences,
                                       genomeStyle = genomeStyle,
                                       chrNormalize = chrNormalize, mapScoreThres = 0.9)

#########1#########2#########3#########4#########5#########6#########7#########8
  getAnywhere("loadReadCountsFromWig")

  getAnywhere("setGenomeStyle")

x

  genomeStyle

  require(GenomeInfoDb)
        #chrs <- genomeStyles(species)[c("NCBI","UCSC")]
        if (!genomeStyle %in% seqlevelsStyle(as.character(x))){
        x <- suppressWarnings(mapSeqlevels(as.character(x),
                                        genomeStyle, drop = FALSE)[1,])
    }

    autoSexMChr <- extractSeqlevelsByGroup(species = species,
                                style = genomeStyle, group = "all")
    x <- x[x %in% autoSexMChr]
    return(x)
}

  require(HMMcopy)
  require(GenomeInfoDb)
  names(counts) <- setGenomeStyle(names(counts), genomeStyle)
	counts.raw <- counts
	counts <- keepChr(counts, chrs)
	if (!is.null(gc)){
		names(gc) <- setGenomeStyle(names(gc), genomeStyle)
		counts$gc <- keepChr(gc, chrs)$value
	}
	if (!is.null(map)){
		names(map) <- setGenomeStyle(names(map), genomeStyle)
		counts$map <- keepChr(map, chrs)$value
	}
	colnames(counts)[1] <- c("reads")

	# remove centromeres
	if (!is.null(centromere)){
		centromere$Chr <- setGenomeStyle(centromere$Chr, genomeStyle)
		counts <- excludeCentromere(counts, centromere, flankLength = flankLength, genomeStyle=genomeStyle)
	}
	# keep targeted sequences
	if (!is.null(targetedSequences)){
		targetedSequences[,1] <- setGenomeStyle(targetedSequences[,1], genomeStyle)
		countsExons <- filterByTargetedSequences(counts, targetedSequences)
		counts <- counts[countsExons$ix,]
	}
	gender <- NULL
	if (applyCorrection){
	## correct read counts ##
    counts <- correctReadCounts(counts, chrNormalize = chrNormalize)
    if (!is.null(map)) {
      ## filter bins by mappability
      counts <- filterByMappabilityScore(counts, map=map, mapScoreThres = mapScoreThres)
    }
    ## get gender ##
    gender <- getGender(counts.raw, counts, gc, map, fracReadsInChrYForMale = fracReadsInChrYForMale,
    					chrXMedianForMale = chrXMedianForMale, useChrY = useChrY,
                        centromere=centromere, flankLength=flankLength, targetedSequences = targetedSequences,
                        genomeStyle = genomeStyle)
    }
  return(list(counts = counts, gender = gender))
}
<bytecode: 0x5add04ee6898>
>
#########1#########2#########3#########4#########5#########6#########7#########8
library(data.table)
library(GenomeInfoDb)

setGenomeStyle <- function(x, genomeStyle = "NCBI", species = "Homo_sapiens") {
    require(GenomeInfoDb)

    # Ensure x is character
    x <- as.character(x)

    # Map seqlevels to the desired style if necessary
    if (!genomeStyle %in% seqlevelsStyle(x)) {
        x <- suppressWarnings(mapSeqlevels(x, genomeStyle, drop = FALSE))
        if (!is.null(x)) {
            x <- x[!is.na(x)]  # Remove NA entries
        } else {
            stop("Mapping seqlevels failed; no valid mappings found.")
        }
    }

    # Filter x to include only valid chromosomes for the species and style
    autoSexMChr <- extractSeqlevelsByGroup(
        species = species,
        style = genomeStyle,
        group = "all"
    )
    x <- x[x %in% autoSexMChr]

    return(x)
}

# Apply setGenomeStyle to the `chr` column of the data.table
gc2 <- gc[chr %in% setGenomeStyle(chr, genomeStyle = "UCSC")]

class(gc2)
gc
#########1#########2#########3#########4#########5#########6#########7#########8

  tumour_copy[[id]] <- counts$counts #as(counts$counts, "GRanges")
  gender <- counts$gender
 	## load in normal file if provided
 	if (!is.null(normal_file)){
		message("Loading normal file:", normal_file)
		normal_reads <- wigToRangedData(normal_file)
		message("Correcting Normal")
		counts <- loadReadCountsFromWig(normal_reads, chrs=chrs, gc=gc, map=map,
				centromere=centromere, flankLength = flankLength, targetedSequences=targetedSequences,
				genomeStyle = genomeStyle, chrNormalize = chrNormalize, mapScoreThres = 0.9)
		normal_copy <- counts$counts #as(counts$counts, "GRanges")
		gender.normal <- counts$gender
	}else{
	  normal_copy <- NULL
	}

	### DETERMINE GENDER ###
	## if normal file not given, use chrY, else use chrX
	message("Determining gender...", appendLF = FALSE)
	gender.mismatch <- FALSE
	if (!is.null(normal_copy)){
	  if (gender$gender != gender.normal$gender){ #use tumour # use normal if given
		# check if normal is same gender as tumour
		  gender.mismatch <- TRUE
		}
	}
	message("Gender ", gender$gender)

  ## NORMALIZE GENOME-WIDE BY MATCHED NORMAL OR NORMAL PANEL (MEDIAN) ##
  tumour_copy[[id]] <- normalizeByPanelOrMatchedNormal(tumour_copy[[id]], chrs = c(1:22, "X", "Y"),
      normal_panel = normal_panel, normal_copy = normal_copy,
      gender = gender$gender, normalizeMaleX = normalizeMaleX)

	### OUTPUT FILE ###
	### PUTTING TOGETHER THE COLUMNS IN THE OUTPUT ###
	outMat <- as.data.frame(tumour_copy[[id]])
	#outMat <- outMat[,c(1,2,3,12)]
	outMat <- outMat[,c("space","start","end","copy")]
	colnames(outMat) <- c("chr","start","end","log2_TNratio_corrected")
	outFile <- paste0(outDir,"/",id,".correctedDepth.txt")
	message(paste("Outputting to:", outFile))
	write.table(outMat, file=outFile, row.names=F, col.names=T, quote=F, sep="\t")

} ## end of for each sample

#########1#########2#########3#########4#########5#########6#########7#########8
require(HMMcopy)
require(GenomeInfoDb)
counts.raw <- counts
counts <- keepChr(counts, chrs)

	if (!is.null(gc)){
		names(gc) <- setGenomeStyle(names(gc), genomeStyle)
		counts$gc <- keepChr(gc, chrs)$value
	}
	if (!is.null(map)){
		names(map) <- setGenomeStyle(names(map), genomeStyle)
		counts$map <- keepChr(map, chrs)$value
	}
	colnames(counts)[1] <- c("reads")

	# remove centromeres
	if (!is.null(centromere)){
		centromere$Chr <- setGenomeStyle(centromere$Chr, genomeStyle)
		counts <- excludeCentromere(counts, centromere, flankLength = flankLength, genomeStyle=genomeStyle)
	}
	# keep targeted sequences
	if (!is.null(targetedSequences)){
		targetedSequences[,1] <- setGenomeStyle(targetedSequences[,1], genomeStyle)
		countsExons <- filterByTargetedSequences(counts, targetedSequences)
		counts <- counts[countsExons$ix,]
	}
	gender <- NULL
	if (applyCorrection){
	## correct read counts ##
    counts <- correctReadCounts(counts, chrNormalize = chrNormalize)
    if (!is.null(map)) {
      ## filter bins by mappability
      counts <- filterByMappabilityScore(counts, map=map, mapScoreThres = mapScoreThres)
    }
    ## get gender ##
    gender <- getGender(counts.raw, counts, gc, map, fracReadsInChrYForMale = fracReadsInChrYForMale,
    					chrXMedianForMale = chrXMedianForMale, useChrY = useChrY,
                        centromere=centromere, flankLength=flankLength, targetedSequences = targetedSequences,
                        genomeStyle = genomeStyle)
    }
  return(list(counts = counts, gender = gender))
}
#+end_src
